<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QCBOR: /Users/lgl/Code/QCBOR/dev/doc/Tagging.md File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QCBOR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="headertitle"><div class="title">/Users/lgl/Code/QCBOR/dev/doc/Tagging.md File Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="anchor" id="CBORTags"></a> </p>
<h1><a class="anchor" id="autotoc_md19"></a>
Types and Tagging in CBOR</h1>
<h2><a class="anchor" id="autotoc_md20"></a>
New Types</h2>
<p>CBOR provides a means for defining new data types beyond the primitive types like integers and strings. These new types can be the simple association of some further semantics with a primitive type or they can be large complex aggregations.</p>
<p>The explicit means for identifying these new types as called tagging. It uses a simple unsigned integer known as the tag number to indicate that the following CBOR is of that type. Officially speaking, a "tag" is made up of exactly a tag number and tag content. The tag content is exactly a single data item, but note that a single data item can be a map or an array which contains further nested maps and arrays and thus arbitrarily complex.</p>
<p>The tag numbers can be up to UINT64_MAX, so there are a lot of them. Some defined in standards and registered in the IANA CBOR Tag Registry. A very large range is available for proprietary tags.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Are Tags "Optional"?</h2>
<p>The description of tags in [RFC 7049] (<a href="https://tools.ietf.org/html/rfc7049">https://tools.ietf.org/html/rfc7049</a>) and in some other places can lead one to think they are optional prefixes that can be ignored at times. This is not true.</p>
<p>As stated above, a tag is exactly a tag number and a single data item that is the tag content. Its purpose in the encoded CBOR is to indicate something is of a data type. Ignoring it would be like ignoring a typedef or struct in C.</p>
<p>However, it is common in CBOR-based protocols to use the format, semantics or definition of the tag content without it actually being a <em>tag</em>. One can think of this as <em>borrowing</em> the tag content or implied type information.</p>
<p>For example, [RFC 8392] (<a href="https://tools.ietf.org/html/rfc8392">https://tools.ietf.org/html/rfc8392</a>) which defines a CBOR Web Token, a CWT, says that the NumericDate field is represented as a CBOR numeric date described as tag 1 in the CBOR standard, but with the tag number 1 omitted from the encoding. A NumericDate is thus not a tag. It just borrows the content format and semantics from tag 1.</p>
<p>This borrowing of the content makes a lot of sense for data items that are labeled members of a map where the type of the data can be easily inferred by the label and the full use of a tag with a tag number would be redundant.</p>
<p>There is another way that tags are "optional". RFC 8392 serves again as an example. A CWT is officially defined as a COSE-secured map containing a bunch of claims where each claim is a labeled data item. This COSE-secured map-of-claims is the definition of a <em>CWT</em> and stands on its own as the definition of a protocol message. One can say that some protocol message is a <em>CWT</em> without ever mention the word tag or the <em>CWT Tag</em>.</p>
<p>Then RFC 8392 goes on to define a <em>CWT Tag</em> as a tag with tag number of 61 and tag content being a <em>CWT</em>. The content format definition comes first and stands on it's own.</p>
<p>To recap, the tags defined in RFC 7049 such as the date formats define the content type of the tag only in the context of the tag itself. To use the content formats outside of the tag, the content format must be borrowed. By contrast some definitions first define the content format in an independent way, then they define a tag to enclose that particular content format. A CWT is of the later sort.</p>
<p>Finally, every CBOR protocol should explicitly spell out how it is using each tag, borrowing tag content and such. If the protocol you are trying to implement doesn't, ask the designer. Generally, protocols designs should not allow for some data item to optional be either a tag or to be the borrowed tag content. While allowing this tag optionality is a form of Postel's law, "be liberal in what you
accept", current wisdom is somewhat the opposite.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Types and Tags in QCBOR</h2>
<p>QCBOR explicitly supports all the tags defined in [RFC 7049] (<a href="https://tools.ietf.org/html/rfc7049">https://tools.ietf.org/html/rfc7049</a>). It has specific APIs and data structures for encoding and decoding them.</p>
<p>These APIs and structures can support either the full and proper tag form or the borrowed content form that is not a tag.</p>
<p>The original QCBOR APIs for encoding tags did not allow for encoding the borrowed content format. They only support the proper tag format. With spiffy decode, a second set of APIs was added that takes and argument to indicate whether the proper tag should be output or just the borrowed content format should be output. The first set are the "AddXxxx" functions and the second the "AddTXxxx" functions.</p>
<p>When decoding with <a class="el" href="qcbor__main__decode_8h.html#a5822b9efabd2a4bb1ce13390bf378b61" title="Preorder traversal like QCBORDecode_VGetNext() without use of internal error state.">QCBORDecode_GetNext()</a>, the non-spiffy decode API, the proper tag form is automatically recognized by the tag number and decoded into QCBORItem. This decoding API however cannot recognize borrowed content format. The caller must tell QCBOR when borrowed content format is expected.</p>
<p>The spiffy decode APIs for the particular tags are the way the caller tells QCBOR to expect borrowed content format. These spiffy decode APIs can also decode the proper tag as well. When asked to decode a proper tag and the input CBOR is not, it is a decode validity error. These APIs take an argument which says whether to expect the proper tag or just the borrowed content. They can also be told to allow either to "be liberal in what you accept", but this is not recommended.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Nested Tags</h2>
<p>CBOR tags are an enclosing or encapsulating format. When one tag encloses another, the enclosed tag is the content for the enclosing tag.</p>
<p>Encoding nested tags is easy with <a class="el" href="qcbor__encode_8h.html#a5973a1e9a37c2192000722205028f32e" title="Add a tag number.">QCBOREncode_AddTagNumber()</a>. Just call it several times before calling the functions to encode the tag content.</p>
<p>When QCBOR decodes tags it does so by first completely processing the built-in tags that it knows how to process. It returns that processed item.</p>
<p>If tags occur that QCBOR doesn't know how to process, it will return the tag content as a <a class="el" href="qcbor__main__decode_8h.html#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> and list the tags that encapsulate. The caller then has the information it needs to process tag that QCBOR did not.</p>
<p>Nesting of tags is certainly used in CBOR protocols, but deep nesting is less common so QCBOR has an implementation limit of 4 levels of tag encapsulation on some tag content. (This can be increased by changing QCBOR_MAX_TAGS_PER_ITEM, but it will increase stack memory use by increasing the size of a QCBORItem).</p>
<p>QCBOR also saves memory by mapping the tag values larger than UINT16_MAX, so the tags have to fetched through an accessor function.</p>
<p>When decoding with <a class="el" href="qcbor__main__decode_8h.html#a5822b9efabd2a4bb1ce13390bf378b61" title="Preorder traversal like QCBORDecode_VGetNext() without use of internal error state.">QCBORDecode_GetNext()</a>, the encapsulating tags are listed in the QCBORItem returned. When decoding with spiffy decoding functions the tags encapsulating the last-decoded item are saved in the decode context and have to be fetched with <a class="el" href="qcbor__tag__decode_8h.html#a367c9fe80082532dfc25165fe590350a" title="Returns the tag numbers for last-decoded item (deprecated).">QCBORDecode_GetNthTagOfLast()</a>.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
Tags for Encapsulated CBOR</h2>
<p>Tag 24 and 63 deserve special mention. The content of these tags is a byte string containing encoded CBOR. The content of tag 24 is a single CBOR data item and the content of tag 63 is a CBOR sequence, more than one data item. Said another way, with tag 24 you can have deeply nested complex structures, but the if you do the one data item must be either a map or an array or a tag that defined to be complex and nested. With tag 63, the content can be a sequence of integers not held together in a map or array. Tag 63 is defined in [RFC 8742] (<a href="https://tools.ietf.org/html/rfc8742">https://tools.ietf.org/html/rfc8742</a>).</p>
<p>The point of encapsulating CBOR this way is often so it can be cryptographically signed. It works well with off-the-shelf encoders and decoders to sign and verify CBOR this way because the decoder can just get the byte string that it needs to hash in a normal way, then feed the content back into another instance of the CBOR decoder.</p>
<p>It is also a way to break up complex CBOR structures so they can be decoded in layers. Usually, with CBOR one error will render the whole structure un-decodable because there is little redundancy in the encoding. By nesting like this, an error in the wrapped CBOR will not cause decoding error in the wrapping CBOR.</p>
<p>QCBOR can be asked to treat these two tags as nesting like maps and arrays are nesting with the spiffy decode <a class="el" href="qcbor__tag__decode_8h.html#a309666f4994d76b00df5d3e3dc689d76" title="Decode some byte-string wrapped CBOR.">QCBORDecode_EnterBstrWrapped()</a> decoding function. It is kind of like entering an array with one item, but with the difference that the end is defined by the end of the byte string not the end of the array.</p>
<p>These tags work like others in that they can be the proper tag or they can be the borrowed content. The QCBOR API supports this as any other tag.</p>
<p>Finally, the payload and protected headers of COSE are worth mentioning here. Neither are officially tag 24 or 63 though they look like it and QCBORs decode APIs can be used on them.</p>
<p>The protected headers are a CBOR byte string that always contains encoded CBOR. It could have been described as tag 24 borrowed content.</p>
<p>The payload is always a byte string, but only sometimes contains encoded CBOR. It never could have been defined as tag 24. When the payload is known to contain CBOR, like the case of a CWT, then QCBOR's <a class="el" href="qcbor__tag__decode_8h.html#a309666f4994d76b00df5d3e3dc689d76" title="Decode some byte-string wrapped CBOR.">QCBORDecode_EnterBstrWrapped()</a> can be used to decode it.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Tags that Can be Ignored</h2>
<p>There are a few specially defined tags that can actually be ignored. These are the following: </p><pre class="fragment">21 Hint that content should be base64url encoded
22 Hint that content should be base64 encoded
23 Hint that content should be base16 encoded
57799 Tag that serves as a CBOR magic number
</pre><p>The content format for all these tags is that it can be any valid CBOR. Decoding of these tags doesn't have to check the content format.</p>
<p>Tag 55799 is not really for consumption by the CBOR decoder. Rather it is for file format checkers and such. The other tags are just hints in how to process the content. They don't really create new data types with new semantics.</p>
<p>Other than these four, just about every other tag defined thus far requires the content to be of a specific type and results in a new data type that a protocol decoder must understand.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Standard Tags and the Tags Registry</h2>
<p>Tags used in CBOR protocols should at least be registered in the [IANA CBOR Tags Registry] (<a href="https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml">https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml</a>). A small number of tags (0-23), are full IETF standards. Further, tags 24-255 require published documentation, but are not full IETF standards. Beyond tag 255, the tags are first come first served.</p>
<p>There is no range for private use, so any tag used in a CBOR protocol should be registered. The range of tag values is very large to accommodate this.</p>
<p>As described above, It is common to use data types from the registry in a CBOR protocol without the explicit tag, so in a way the registry is a registry of data types.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Tag Decoding</h2>
<p>QCBOR offers two ways to decoding tags.</p>
<p>The first is by registering a call back that can transform the tag into a QCBORItem itendified by a new QCBOR Type. It is limited in that the decoded data must fit into the 24 bytes of a QCBORItem values. It is good for new data types.</p>
<p>The second is by getting tag numbers in the course of decoding. This is more suitable for tags numbers that indicate message types, those that alter the decode flow.</p>
<p>QCBOR v2 (when not in v1 compatibility) requires all tags be consumed. If they are not consumed by one of the above methods, xxxx error occurs. They are never optional (as they were described in RFC 7049) just is it is not optional to ignore whether an item is a string rather than an integer.</p>
<p>In v2</p>
<p>TODO: make clean this up</p>
<p>When asking for specific tag decode, for example GetDateEpoch()</p>
<p>Tag required</p><ul>
<li>No tag gives error xxxx</li>
<li>The epoch date tag by itself succeeds</li>
<li>The epoch date tag with wrong content gives error yyy</li>
<li>The epoch date tag with additional</li>
<li>The additional have been consumed &ndash; suceeds</li>
<li>The aditional tags have not been consumed &ndash; gives error aaa</li>
<li>Another tag gives &mdash; error zzz</li>
</ul>
<p>Tag not required</p><ul>
<li>No tags, correct tag content &ndash; success</li>
<li>No tags, incorrect tag content type error yyy</li>
<li>Another tag, not consumed &mdash; error aaa</li>
<li>Another tag consumed &ndash; success</li>
<li>Another tag consumed and made into another type &mdash; error xxxx</li>
</ul>
<p>Tag optional</p><ul>
<li>No tags, correct content &ndash; success</li>
<li>No tags, incorrect content &ndash; error yyy</li>
<li>Expected tag &ndash; success</li>
<li>Another tag, consumed &ndash; success</li>
<li>Another tag, not consumed tag content correct &ndash; error, probably aaa</li>
<li>Another tag, consumed and made into another type &ndash; error xxx</li>
<li>Expected tag + another tag, not consumed &ndash; error aaa</li>
</ul>
<p>Now fan out for ALLOW_EXTRA &mdash; yuckkkkk</p>
<p>Ignore ALLOW_EXTRA in v2?</p>
<p>Fan out for v1</p>
<p>0(140) good date tag 50000(140) interpret as a date with some other tag on it &ndash; must be consumed, so unconsumed tag error intepret this as not a date &ndash; wrong type error subjective depending on whether tag content decoder is installed 1(140) same as above</p>
<p>Tag optional</p>
<h2><a class="anchor" id="autotoc_md28"></a>
See Also</h2>
<p>See <a class="el" href="qcbor__encode_8h.html#Tags-Overview">Tags-Overview</a> and <a class="el" href="qcbor__tag__decode_8h.html#Tag-Usage">Tag-Usage</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
