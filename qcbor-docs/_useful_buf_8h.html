<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QCBOR: /Users/lgl/Code/QCBOR/dev/inc/qcbor/UsefulBuf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QCBOR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bfccd401955b95cf8c75461437045ac0.html">inc</a></li><li class="navelem"><a class="el" href="dir_6c17abd51158f5ea9edde975dd55b13d.html">qcbor</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">UsefulBuf.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div>
<p><a href="_useful_buf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structq__useful__buf__c.html">q_useful_buf_c</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structq__useful__buf.html">q_useful_buf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuseful__out__buf.html">useful_out_buf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuseful__input__buf.html">useful_input_buf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aef281b38ce49e9413dad0893d225c70d" id="r_aef281b38ce49e9413dad0893d225c70d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a>&#160;&#160;&#160;((<a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>) {NULL, 0})</td></tr>
<tr class="separator:aef281b38ce49e9413dad0893d225c70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac590bc10c66f484fe139b361fe01c339" id="r_ac590bc10c66f484fe139b361fe01c339"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac590bc10c66f484fe139b361fe01c339">NULLUsefulBuf</a>&#160;&#160;&#160;((<a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>) {NULL, 0})</td></tr>
<tr class="separator:ac590bc10c66f484fe139b361fe01c339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778543dc5c8297cbfdc8b1716ebce423" id="r_a778543dc5c8297cbfdc8b1716ebce423"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a778543dc5c8297cbfdc8b1716ebce423">UsefulBuf_FROM_SZ_LITERAL</a>(szString)</td></tr>
<tr class="separator:a778543dc5c8297cbfdc8b1716ebce423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc60f139ca7be95de2de18e5ea966ee" id="r_aacc60f139ca7be95de2de18e5ea966ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacc60f139ca7be95de2de18e5ea966ee">UsefulBuf_FROM_BYTE_ARRAY_LITERAL</a>(pBytes)</td></tr>
<tr class="separator:aacc60f139ca7be95de2de18e5ea966ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace69a6220419dd9dc204770c5b87efb6" id="r_ace69a6220419dd9dc204770c5b87efb6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace69a6220419dd9dc204770c5b87efb6">UsefulBuf_MAKE_STACK_UB</a>(name,  size)</td></tr>
<tr class="separator:ace69a6220419dd9dc204770c5b87efb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98eb36e1bdeab13b58d8a077d26bee86" id="r_a98eb36e1bdeab13b58d8a077d26bee86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98eb36e1bdeab13b58d8a077d26bee86">UsefulBuf_FROM_BYTE_ARRAY</a>(pBytes)</td></tr>
<tr class="separator:a98eb36e1bdeab13b58d8a077d26bee86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3255da9088f245f9662f522758be3fb" id="r_ad3255da9088f245f9662f522758be3fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3255da9088f245f9662f522758be3fb">UsefulBufC_NTH_BYTE</a>(UBC,  n)</td></tr>
<tr class="memdesc:ad3255da9088f245f9662f522758be3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth byte from a UsefulBufC.  <br /></td></tr>
<tr class="separator:ad3255da9088f245f9662f522758be3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22233f9d4579def61e77b006a78469ea" id="r_a22233f9d4579def61e77b006a78469ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22233f9d4579def61e77b006a78469ea">SZLiteralToUsefulBufC</a>(szString)</td></tr>
<tr class="separator:a22233f9d4579def61e77b006a78469ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8bfa82f56a0471331d2c4adaacfb61" id="r_acb8bfa82f56a0471331d2c4adaacfb61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb8bfa82f56a0471331d2c4adaacfb61">MakeUsefulBufOnStack</a>(name,  size)</td></tr>
<tr class="separator:acb8bfa82f56a0471331d2c4adaacfb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eabda18ec4acfa382b7a805a86f2189" id="r_a9eabda18ec4acfa382b7a805a86f2189"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eabda18ec4acfa382b7a805a86f2189">ByteArrayLiteralToUsefulBufC</a>(pBytes)</td></tr>
<tr class="separator:a9eabda18ec4acfa382b7a805a86f2189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4919809b569fd7fc5ead3fa926c9de" id="r_a7b4919809b569fd7fc5ead3fa926c9de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b4919809b569fd7fc5ead3fa926c9de">SizeCalculateUsefulBuf</a>&#160;&#160;&#160;((<a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>) {NULL, SIZE_MAX})</td></tr>
<tr class="separator:a7b4919809b569fd7fc5ead3fa926c9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fed8f0b3943666846bae738004dfbe" id="r_a54fed8f0b3943666846bae738004dfbe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54fed8f0b3943666846bae738004dfbe">UsefulOutBuf_MakeOnStack</a>(name,  size)</td></tr>
<tr class="separator:a54fed8f0b3943666846bae738004dfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e8acba0f0d344d630494c9bd76ec7b" id="r_af1e8acba0f0d344d630494c9bd76ec7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1e8acba0f0d344d630494c9bd76ec7b">UIB_MAGIC</a>&#160;&#160;&#160;(0xB00F)</td></tr>
<tr class="separator:af1e8acba0f0d344d630494c9bd76ec7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad5ebb3732bd85ff732cc817fc280cc64" id="r_ad5ebb3732bd85ff732cc817fc280cc64"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structq__useful__buf__c.html">q_useful_buf_c</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td></tr>
<tr class="separator:ad5ebb3732bd85ff732cc817fc280cc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f72e9ae0a9419e46735e16f8c2f449" id="r_a28f72e9ae0a9419e46735e16f8c2f449"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structq__useful__buf.html">q_useful_buf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></td></tr>
<tr class="separator:a28f72e9ae0a9419e46735e16f8c2f449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f01ed9a781335a27e651b4d0fe99cd" id="r_a83f01ed9a781335a27e651b4d0fe99cd"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structuseful__out__buf.html">useful_out_buf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a></td></tr>
<tr class="separator:a83f01ed9a781335a27e651b4d0fe99cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40147dc1c6e6ab03d7690b195b21603f" id="r_a40147dc1c6e6ab03d7690b195b21603f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structuseful__input__buf.html">useful_input_buf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a></td></tr>
<tr class="separator:a40147dc1c6e6ab03d7690b195b21603f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a682553796f9ce5361bc9a70d4347444d" id="r_a682553796f9ce5361bc9a70d4347444d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a682553796f9ce5361bc9a70d4347444d">UsefulBuf_IsNULL</a> (<a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> UB)</td></tr>
<tr class="memdesc:a682553796f9ce5361bc9a70d4347444d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is <a class="el" href="#ac590bc10c66f484fe139b361fe01c339">NULLUsefulBuf</a> or not.  <br /></td></tr>
<tr class="separator:a682553796f9ce5361bc9a70d4347444d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfed827589d6ed9f53a650ddd58b58a" id="r_a5bfed827589d6ed9f53a650ddd58b58a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bfed827589d6ed9f53a650ddd58b58a">UsefulBuf_IsNULLC</a> (<a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UB)</td></tr>
<tr class="memdesc:a5bfed827589d6ed9f53a650ddd58b58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> is <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> or not.  <br /></td></tr>
<tr class="separator:a5bfed827589d6ed9f53a650ddd58b58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af571fcde9e6463bfef16b30e2cd76c1f" id="r_af571fcde9e6463bfef16b30e2cd76c1f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af571fcde9e6463bfef16b30e2cd76c1f">UsefulBuf_IsEmpty</a> (<a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> UB)</td></tr>
<tr class="memdesc:af571fcde9e6463bfef16b30e2cd76c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is empty or not.  <br /></td></tr>
<tr class="separator:af571fcde9e6463bfef16b30e2cd76c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e21918b707e90e5a8af563eaaa1c5d" id="r_a64e21918b707e90e5a8af563eaaa1c5d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64e21918b707e90e5a8af563eaaa1c5d">UsefulBuf_IsEmptyC</a> (<a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UB)</td></tr>
<tr class="memdesc:a64e21918b707e90e5a8af563eaaa1c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> is empty or not.  <br /></td></tr>
<tr class="separator:a64e21918b707e90e5a8af563eaaa1c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae9f4782b8555340d73e8d63ec2691e" id="r_aeae9f4782b8555340d73e8d63ec2691e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeae9f4782b8555340d73e8d63ec2691e">UsefulBuf_IsNULLOrEmpty</a> (<a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> UB)</td></tr>
<tr class="memdesc:aeae9f4782b8555340d73e8d63ec2691e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is <a class="el" href="#ac590bc10c66f484fe139b361fe01c339">NULLUsefulBuf</a> or empty.  <br /></td></tr>
<tr class="separator:aeae9f4782b8555340d73e8d63ec2691e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca503e3b347234429acf80e460e31cdd" id="r_aca503e3b347234429acf80e460e31cdd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca503e3b347234429acf80e460e31cdd">UsefulBuf_IsNULLOrEmptyC</a> (<a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UB)</td></tr>
<tr class="memdesc:aca503e3b347234429acf80e460e31cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> is <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> or empty.  <br /></td></tr>
<tr class="separator:aca503e3b347234429acf80e460e31cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b9924b51c67d6363fae93c0c6b4a95" id="r_ad1b9924b51c67d6363fae93c0c6b4a95"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1b9924b51c67d6363fae93c0c6b4a95">UsefulBuf_Const</a> (const <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> UB)</td></tr>
<tr class="memdesc:ad1b9924b51c67d6363fae93c0c6b4a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a non-const <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> to a const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>.  <br /></td></tr>
<tr class="separator:ad1b9924b51c67d6363fae93c0c6b4a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d237545f02c630dc59d1d9a4540df1" id="r_a12d237545f02c630dc59d1d9a4540df1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12d237545f02c630dc59d1d9a4540df1">UsefulBuf_Unconst</a> (const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UBC)</td></tr>
<tr class="memdesc:a12d237545f02c630dc59d1d9a4540df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> to a non-const <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>.  <br /></td></tr>
<tr class="separator:a12d237545f02c630dc59d1d9a4540df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f51e2194792e98be0a0192579e3e2b" id="r_a29f51e2194792e98be0a0192579e3e2b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29f51e2194792e98be0a0192579e3e2b">UsefulBuf_FromSZ</a> (const char *szString)</td></tr>
<tr class="memdesc:a29f51e2194792e98be0a0192579e3e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a NULL-terminated string to a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>.  <br /></td></tr>
<tr class="separator:a29f51e2194792e98be0a0192579e3e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cbe966444cc482aaeef036ae801ebd" id="r_a82cbe966444cc482aaeef036ae801ebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82cbe966444cc482aaeef036ae801ebd">UsefulBuf_CopyOffset</a> (<a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> Dest, size_t uOffset, const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> Src)</td></tr>
<tr class="memdesc:a82cbe966444cc482aaeef036ae801ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> into another at an offset.  <br /></td></tr>
<tr class="separator:a82cbe966444cc482aaeef036ae801ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4fb99a895e5384d30814ca07756777" id="r_acb4fb99a895e5384d30814ca07756777"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb4fb99a895e5384d30814ca07756777">UsefulBuf_Copy</a> (<a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> Dest, const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> Src)</td></tr>
<tr class="memdesc:acb4fb99a895e5384d30814ca07756777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> into another.  <br /></td></tr>
<tr class="separator:acb4fb99a895e5384d30814ca07756777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f9265753384286f3a1aaf394f00bf7" id="r_a71f9265753384286f3a1aaf394f00bf7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71f9265753384286f3a1aaf394f00bf7">UsefulBuf_Set</a> (<a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> pDest, uint8_t value)</td></tr>
<tr class="memdesc:a71f9265753384286f3a1aaf394f00bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all bytes in a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> to a value, for example to 0.  <br /></td></tr>
<tr class="separator:a71f9265753384286f3a1aaf394f00bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5424debf4c272ca43654d4f1a65173aa" id="r_a5424debf4c272ca43654d4f1a65173aa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5424debf4c272ca43654d4f1a65173aa">UsefulBuf_CopyPtr</a> (<a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> Dest, const void *ptr, size_t uLen)</td></tr>
<tr class="memdesc:a5424debf4c272ca43654d4f1a65173aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a pointer into a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>.  <br /></td></tr>
<tr class="separator:a5424debf4c272ca43654d4f1a65173aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a21703d4dac011f8ecb3f695ee3c59" id="r_ad8a21703d4dac011f8ecb3f695ee3c59"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8a21703d4dac011f8ecb3f695ee3c59">UsefulBuf_Head</a> (<a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UB, size_t uAmount)</td></tr>
<tr class="memdesc:ad8a21703d4dac011f8ecb3f695ee3c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a truncation of a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>.  <br /></td></tr>
<tr class="separator:ad8a21703d4dac011f8ecb3f695ee3c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaceb62d7b73b18be451c06a5d2540e5" id="r_adaceb62d7b73b18be451c06a5d2540e5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaceb62d7b73b18be451c06a5d2540e5">UsefulBuf_Tail</a> (<a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UB, size_t uAmount)</td></tr>
<tr class="memdesc:adaceb62d7b73b18be451c06a5d2540e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns bytes from the end of a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>.  <br /></td></tr>
<tr class="separator:adaceb62d7b73b18be451c06a5d2540e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57b19dfa682d1806296f891bee01693" id="r_ab57b19dfa682d1806296f891bee01693"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab57b19dfa682d1806296f891bee01693">UsefulBuf_Compare</a> (const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UB1, const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UB2)</td></tr>
<tr class="memdesc:ab57b19dfa682d1806296f891bee01693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare one <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> to another.  <br /></td></tr>
<tr class="separator:ab57b19dfa682d1806296f891bee01693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15cfdf544b8f3cf7b42351f0b3d7ad3" id="r_aa15cfdf544b8f3cf7b42351f0b3d7ad3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa15cfdf544b8f3cf7b42351f0b3d7ad3">UsefulBuf_IsValue</a> (const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UB, uint8_t uValue)</td></tr>
<tr class="memdesc:aa15cfdf544b8f3cf7b42351f0b3d7ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first byte that is not a particular byte value.  <br /></td></tr>
<tr class="separator:aa15cfdf544b8f3cf7b42351f0b3d7ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a028eb81150d93fc1fc83b1ea7ac6b" id="r_a08a028eb81150d93fc1fc83b1ea7ac6b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08a028eb81150d93fc1fc83b1ea7ac6b">UsefulBuf_FindBytes</a> (<a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> BytesToSearch, <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> BytesToFind)</td></tr>
<tr class="memdesc:a08a028eb81150d93fc1fc83b1ea7ac6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find one <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> in another.  <br /></td></tr>
<tr class="separator:a08a028eb81150d93fc1fc83b1ea7ac6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42353fc50fa085d44d28e3fb5dcf7f4" id="r_aa42353fc50fa085d44d28e3fb5dcf7f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa42353fc50fa085d44d28e3fb5dcf7f4">UsefulBuf_SkipLeading</a> (<a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> String, uint8_t uByte)</td></tr>
<tr class="memdesc:aa42353fc50fa085d44d28e3fb5dcf7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip leading bytes of a particular value in a string.  <br /></td></tr>
<tr class="separator:aa42353fc50fa085d44d28e3fb5dcf7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413d8a142633d8b061d2639063c840fb" id="r_a413d8a142633d8b061d2639063c840fb"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a413d8a142633d8b061d2639063c840fb">UsefulBuf_PointerToOffset</a> (<a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UB, const void *p)</td></tr>
<tr class="memdesc:a413d8a142633d8b061d2639063c840fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pointer to an offset with bounds checking.  <br /></td></tr>
<tr class="separator:a413d8a142633d8b061d2639063c840fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92870bf6b3632564213eb3f877c55a85" id="r_a92870bf6b3632564213eb3f877c55a85"><td class="memItemLeft" align="right" valign="top">static const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92870bf6b3632564213eb3f877c55a85">UsefulBuf_OffsetToPointer</a> (<a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UB, size_t uOffset)</td></tr>
<tr class="memdesc:a92870bf6b3632564213eb3f877c55a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an offset to a pointer with bounds checking.  <br /></td></tr>
<tr class="separator:a92870bf6b3632564213eb3f877c55a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8f5b0328bb3a5575e7d726e4499f71" id="r_a7b8f5b0328bb3a5575e7d726e4499f71"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b8f5b0328bb3a5575e7d726e4499f71">UsefulBufC_Unconst</a> (const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UBC)</td></tr>
<tr class="separator:a7b8f5b0328bb3a5575e7d726e4499f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4e7c2dc2a448f714b95c6440fc81cb" id="r_a3f4e7c2dc2a448f714b95c6440fc81cb"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f4e7c2dc2a448f714b95c6440fc81cb">UsefulBufUtil_CopyFloatToUint32</a> (float f)</td></tr>
<tr class="memdesc:a3f4e7c2dc2a448f714b95c6440fc81cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a <code>float</code> to a <code>uint32_t</code>.  <br /></td></tr>
<tr class="separator:a3f4e7c2dc2a448f714b95c6440fc81cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728daeea6ec716b8a444d96b281ecd5f" id="r_a728daeea6ec716b8a444d96b281ecd5f"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a728daeea6ec716b8a444d96b281ecd5f">UsefulBufUtil_CopyDoubleToUint64</a> (double d)</td></tr>
<tr class="memdesc:a728daeea6ec716b8a444d96b281ecd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a <code>double</code> to a <code>uint64_t</code>.  <br /></td></tr>
<tr class="separator:a728daeea6ec716b8a444d96b281ecd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eb31f1337f07b203260f598068ea1c" id="r_a63eb31f1337f07b203260f598068ea1c"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63eb31f1337f07b203260f598068ea1c">UsefulBufUtil_CopyUint32ToFloat</a> (uint32_t u32)</td></tr>
<tr class="memdesc:a63eb31f1337f07b203260f598068ea1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a <code>uint32_t</code> to a <code>float</code>.  <br /></td></tr>
<tr class="separator:a63eb31f1337f07b203260f598068ea1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab72301ac77d863027528333ae31152" id="r_a9ab72301ac77d863027528333ae31152"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ab72301ac77d863027528333ae31152">UsefulBufUtil_CopyUint64ToDouble</a> (uint64_t u64)</td></tr>
<tr class="memdesc:a9ab72301ac77d863027528333ae31152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a <code>uint64_t</code> to a <code>double</code>.  <br /></td></tr>
<tr class="separator:a9ab72301ac77d863027528333ae31152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913b2d897a56ee1ea3c0fd981160af31" id="r_a913b2d897a56ee1ea3c0fd981160af31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31">UsefulOutBuf_Init</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> Storage)</td></tr>
<tr class="memdesc:a913b2d897a56ee1ea3c0fd981160af31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize and supply the output buffer.  <br /></td></tr>
<tr class="separator:a913b2d897a56ee1ea3c0fd981160af31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ad9eb0d31c4d17d92cff3cc31187a9" id="r_ab3ad9eb0d31c4d17d92cff3cc31187a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3ad9eb0d31c4d17d92cff3cc31187a9">UsefulOutBuf_Reset</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf)</td></tr>
<tr class="memdesc:ab3ad9eb0d31c4d17d92cff3cc31187a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> for re use.  <br /></td></tr>
<tr class="separator:ab3ad9eb0d31c4d17d92cff3cc31187a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f2204c0b8879f583affacbe45c907d" id="r_a18f2204c0b8879f583affacbe45c907d"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18f2204c0b8879f583affacbe45c907d">UsefulOutBuf_GetEndPosition</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf)</td></tr>
<tr class="memdesc:a18f2204c0b8879f583affacbe45c907d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns position of end of data in the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a18f2204c0b8879f583affacbe45c907d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec55d5cccfd2e52bd482d3914d431c6c" id="r_aec55d5cccfd2e52bd482d3914d431c6c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec55d5cccfd2e52bd482d3914d431c6c">UsefulOutBuf_AtStart</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf)</td></tr>
<tr class="memdesc:aec55d5cccfd2e52bd482d3914d431c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether any data has been added to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:aec55d5cccfd2e52bd482d3914d431c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ea2a68453e34fea416d52017b4b37c" id="r_a09ea2a68453e34fea416d52017b4b37c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09ea2a68453e34fea416d52017b4b37c">UsefulOutBuf_InsertUsefulBuf</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> NewData, size_t uPos)</td></tr>
<tr class="memdesc:a09ea2a68453e34fea416d52017b4b37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts bytes into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a09ea2a68453e34fea416d52017b4b37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2686ae4114c2e5774bb8eb613f72f480" id="r_a2686ae4114c2e5774bb8eb613f72f480"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2686ae4114c2e5774bb8eb613f72f480">UsefulOutBuf_InsertData</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, const void *pBytes, size_t uLen, size_t uPos)</td></tr>
<tr class="memdesc:a2686ae4114c2e5774bb8eb613f72f480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a data buffer into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a2686ae4114c2e5774bb8eb613f72f480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14baa7dec0d821f7069a74de20d86ce4" id="r_a14baa7dec0d821f7069a74de20d86ce4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14baa7dec0d821f7069a74de20d86ce4">UsefulOutBuf_InsertString</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, const char *szString, size_t uPos)</td></tr>
<tr class="memdesc:a14baa7dec0d821f7069a74de20d86ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a NULL-terminated string into the UsefulOutBuf.  <br /></td></tr>
<tr class="separator:a14baa7dec0d821f7069a74de20d86ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0755837a7524edfc48ea93ce7abd0349" id="r_a0755837a7524edfc48ea93ce7abd0349"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0755837a7524edfc48ea93ce7abd0349">UsefulOutBuf_InsertByte</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, uint8_t byte, size_t uPos)</td></tr>
<tr class="memdesc:a0755837a7524edfc48ea93ce7abd0349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a byte into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a0755837a7524edfc48ea93ce7abd0349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808dcfbb6f16830bc958554ad5449848" id="r_a808dcfbb6f16830bc958554ad5449848"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a808dcfbb6f16830bc958554ad5449848">UsefulOutBuf_InsertUint16</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, uint16_t uInteger16, size_t uPos)</td></tr>
<tr class="memdesc:a808dcfbb6f16830bc958554ad5449848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a 16-bit integer into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a808dcfbb6f16830bc958554ad5449848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b021d38c832add340d82e474a1d14ff" id="r_a4b021d38c832add340d82e474a1d14ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b021d38c832add340d82e474a1d14ff">UsefulOutBuf_InsertUint32</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, uint32_t uInteger32, size_t uPos)</td></tr>
<tr class="memdesc:a4b021d38c832add340d82e474a1d14ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a 32-bit integer into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a4b021d38c832add340d82e474a1d14ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85576eaefd482c7e6ee9483914f63af" id="r_ae85576eaefd482c7e6ee9483914f63af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae85576eaefd482c7e6ee9483914f63af">UsefulOutBuf_InsertUint64</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, uint64_t uInteger64, size_t uPos)</td></tr>
<tr class="memdesc:ae85576eaefd482c7e6ee9483914f63af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a 64-bit integer into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:ae85576eaefd482c7e6ee9483914f63af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f7f3fc882951f16eb8ed0c5c8ba10f" id="r_a14f7f3fc882951f16eb8ed0c5c8ba10f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14f7f3fc882951f16eb8ed0c5c8ba10f">UsefulOutBuf_InsertFloat</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, float f, size_t uPos)</td></tr>
<tr class="memdesc:a14f7f3fc882951f16eb8ed0c5c8ba10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a <code>float</code> into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a14f7f3fc882951f16eb8ed0c5c8ba10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d0d70e0e85b9daee24ebf93944e44b" id="r_a90d0d70e0e85b9daee24ebf93944e44b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90d0d70e0e85b9daee24ebf93944e44b">UsefulOutBuf_InsertDouble</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, double d, size_t uPos)</td></tr>
<tr class="memdesc:a90d0d70e0e85b9daee24ebf93944e44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a <code>double</code> into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a90d0d70e0e85b9daee24ebf93944e44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a089d10c8426c57649db193c493881" id="r_a19a089d10c8426c57649db193c493881"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19a089d10c8426c57649db193c493881">UsefulOutBuf_AppendUsefulBuf</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> NewData)</td></tr>
<tr class="memdesc:a19a089d10c8426c57649db193c493881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a19a089d10c8426c57649db193c493881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7de54cb1ffbd885b6166d485fdaa6e" id="r_a6d7de54cb1ffbd885b6166d485fdaa6e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d7de54cb1ffbd885b6166d485fdaa6e">UsefulOutBuf_AppendData</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, const void *pBytes, size_t uLen)</td></tr>
<tr class="memdesc:a6d7de54cb1ffbd885b6166d485fdaa6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append bytes to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a6d7de54cb1ffbd885b6166d485fdaa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768e60e66ce61bca92aa6647d7983c00" id="r_a768e60e66ce61bca92aa6647d7983c00"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a768e60e66ce61bca92aa6647d7983c00">UsefulOutBuf_AppendString</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, const char *szString)</td></tr>
<tr class="memdesc:a768e60e66ce61bca92aa6647d7983c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a NULL-terminated string to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a768e60e66ce61bca92aa6647d7983c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae2711f8017f87f92b31327beb2e026" id="r_abae2711f8017f87f92b31327beb2e026"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abae2711f8017f87f92b31327beb2e026">UsefulOutBuf_AppendByte</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, uint8_t byte)</td></tr>
<tr class="memdesc:abae2711f8017f87f92b31327beb2e026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a byte to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:abae2711f8017f87f92b31327beb2e026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849e4cd2189f034211ad8ed3bc41884d" id="r_a849e4cd2189f034211ad8ed3bc41884d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a849e4cd2189f034211ad8ed3bc41884d">UsefulOutBuf_AppendUint16</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, uint16_t uInteger16)</td></tr>
<tr class="memdesc:a849e4cd2189f034211ad8ed3bc41884d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an integer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a849e4cd2189f034211ad8ed3bc41884d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac934b99c15fc41c92d3197a2af6b19" id="r_a6ac934b99c15fc41c92d3197a2af6b19"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ac934b99c15fc41c92d3197a2af6b19">UsefulOutBuf_AppendUint32</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, uint32_t uInteger32)</td></tr>
<tr class="memdesc:a6ac934b99c15fc41c92d3197a2af6b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an integer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a6ac934b99c15fc41c92d3197a2af6b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9458ac79088de56c744b6ae6e1348854" id="r_a9458ac79088de56c744b6ae6e1348854"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9458ac79088de56c744b6ae6e1348854">UsefulOutBuf_AppendUint64</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, uint64_t uInteger64)</td></tr>
<tr class="memdesc:a9458ac79088de56c744b6ae6e1348854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an integer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a9458ac79088de56c744b6ae6e1348854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e383cad22b2a869e55fa1320c655ad" id="r_a85e383cad22b2a869e55fa1320c655ad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85e383cad22b2a869e55fa1320c655ad">UsefulOutBuf_AppendFloat</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, float f)</td></tr>
<tr class="memdesc:a85e383cad22b2a869e55fa1320c655ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a <code>float</code> to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a85e383cad22b2a869e55fa1320c655ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568daf99d886e2c874918d7550336674" id="r_a568daf99d886e2c874918d7550336674"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a568daf99d886e2c874918d7550336674">UsefulOutBuf_AppendDouble</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, double d)</td></tr>
<tr class="memdesc:a568daf99d886e2c874918d7550336674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a <code>double</code> to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a568daf99d886e2c874918d7550336674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb574af9a0ea67d95d3bdf2e6821dfe6" id="r_aeb574af9a0ea67d95d3bdf2e6821dfe6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb574af9a0ea67d95d3bdf2e6821dfe6">UsefulOutBuf_GetError</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf)</td></tr>
<tr class="memdesc:aeb574af9a0ea67d95d3bdf2e6821dfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current error status.  <br /></td></tr>
<tr class="separator:aeb574af9a0ea67d95d3bdf2e6821dfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65d3e33564d8c1736abffd0e7efa5c2" id="r_aa65d3e33564d8c1736abffd0e7efa5c2"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa65d3e33564d8c1736abffd0e7efa5c2">UsefulOutBuf_RoomLeft</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf)</td></tr>
<tr class="memdesc:aa65d3e33564d8c1736abffd0e7efa5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of bytes unused used in the output buffer.  <br /></td></tr>
<tr class="separator:aa65d3e33564d8c1736abffd0e7efa5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098521172d27985c967cfb0b6ee07ba3" id="r_a098521172d27985c967cfb0b6ee07ba3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a098521172d27985c967cfb0b6ee07ba3">UsefulOutBuf_WillItFit</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, size_t uLen)</td></tr>
<tr class="memdesc:a098521172d27985c967cfb0b6ee07ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if some number of bytes will fit in the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a098521172d27985c967cfb0b6ee07ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52b96191e812bad2e9b53f889126d62" id="r_ab52b96191e812bad2e9b53f889126d62"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab52b96191e812bad2e9b53f889126d62">UsefulOutBuf_IsBufferNULL</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf)</td></tr>
<tr class="memdesc:ab52b96191e812bad2e9b53f889126d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if buffer given to <a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31" title="Initialize and supply the output buffer.">UsefulOutBuf_Init()</a> was <code>NULL</code>.  <br /></td></tr>
<tr class="separator:ab52b96191e812bad2e9b53f889126d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9187cdecc1b636f2c4b6898db781dd7b" id="r_a9187cdecc1b636f2c4b6898db781dd7b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9187cdecc1b636f2c4b6898db781dd7b">UsefulOutBuf_GetOutPlace</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf)</td></tr>
<tr class="memdesc:a9187cdecc1b636f2c4b6898db781dd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer and length of the output buffer not yet used.  <br /></td></tr>
<tr class="separator:a9187cdecc1b636f2c4b6898db781dd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec6768d1886aacabb09650ecd176316" id="r_a5ec6768d1886aacabb09650ecd176316"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ec6768d1886aacabb09650ecd176316">UsefulOutBuf_Advance</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, size_t uAmount)</td></tr>
<tr class="memdesc:a5ec6768d1886aacabb09650ecd176316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the amount output assuming it was written by the caller.  <br /></td></tr>
<tr class="separator:a5ec6768d1886aacabb09650ecd176316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eb02690d07e40dfdda3286bc332dbf" id="r_a08eb02690d07e40dfdda3286bc332dbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08eb02690d07e40dfdda3286bc332dbf">UsefulOutBuf_OutUBuf</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf)</td></tr>
<tr class="memdesc:a08eb02690d07e40dfdda3286bc332dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data put into a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a08eb02690d07e40dfdda3286bc332dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282b65088cb6f2f39c01edfbd06ca5a1" id="r_a282b65088cb6f2f39c01edfbd06ca5a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a282b65088cb6f2f39c01edfbd06ca5a1">UsefulOutBuf_CopyOut</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> Dest)</td></tr>
<tr class="memdesc:a282b65088cb6f2f39c01edfbd06ca5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy out the data put into a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a282b65088cb6f2f39c01edfbd06ca5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c955cf8da5037e148e7c9d8e28e068" id="r_a98c955cf8da5037e148e7c9d8e28e068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98c955cf8da5037e148e7c9d8e28e068">UsefulOutBuf_OutUBufOffset</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, size_t uOffset)</td></tr>
<tr class="memdesc:a98c955cf8da5037e148e7c9d8e28e068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns data starting at an offset that was put into a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.  <br /></td></tr>
<tr class="separator:a98c955cf8da5037e148e7c9d8e28e068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f7b80b24ef6a768d32129077978f98" id="r_a72f7b80b24ef6a768d32129077978f98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72f7b80b24ef6a768d32129077978f98">UsefulOutBuf_SubString</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, const size_t uStart, const size_t uLen)</td></tr>
<tr class="memdesc:a72f7b80b24ef6a768d32129077978f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a substring of the output data.  <br /></td></tr>
<tr class="separator:a72f7b80b24ef6a768d32129077978f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0ee8b7e2c3b9e221b166d4a786ec91" id="r_a4d0ee8b7e2c3b9e221b166d4a786ec91"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d0ee8b7e2c3b9e221b166d4a786ec91">UsefulOutBuf_RetrieveOutputStorage</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf)</td></tr>
<tr class="memdesc:a4d0ee8b7e2c3b9e221b166d4a786ec91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the storage buffer passed in to <a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31" title="Initialize and supply the output buffer.">UsefulOutBuf_Init()</a>.  <br /></td></tr>
<tr class="separator:a4d0ee8b7e2c3b9e221b166d4a786ec91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2485bb0b5363c9a98af71f34d8d443d" id="r_ab2485bb0b5363c9a98af71f34d8d443d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2485bb0b5363c9a98af71f34d8d443d">UsefulOutBuf_Compare</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, size_t uStart1, size_t uLen1, size_t uStart2, size_t uLen2)</td></tr>
<tr class="memdesc:ab2485bb0b5363c9a98af71f34d8d443d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare bytes at offsets.  <br /></td></tr>
<tr class="separator:ab2485bb0b5363c9a98af71f34d8d443d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39613dac2316e85a665bd5000692b15c" id="r_a39613dac2316e85a665bd5000692b15c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39613dac2316e85a665bd5000692b15c">UsefulOutBuf_Swap</a> (<a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *pUOutBuf, size_t uStartOffset, size_t uPivotOffset, size_t uEndOffset)</td></tr>
<tr class="memdesc:a39613dac2316e85a665bd5000692b15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two regions of output bytes.  <br /></td></tr>
<tr class="separator:a39613dac2316e85a665bd5000692b15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d00cc7d9fc4fe1427cc43aeb3bfc35" id="r_a52d00cc7d9fc4fe1427cc43aeb3bfc35"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52d00cc7d9fc4fe1427cc43aeb3bfc35">UsefulInputBuf_Init</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf, <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UB)</td></tr>
<tr class="memdesc:a52d00cc7d9fc4fe1427cc43aeb3bfc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> structure before use.  <br /></td></tr>
<tr class="separator:a52d00cc7d9fc4fe1427cc43aeb3bfc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74100a089e88487f1fbfc66a4eb6b615" id="r_a74100a089e88487f1fbfc66a4eb6b615"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74100a089e88487f1fbfc66a4eb6b615">UsefulInputBuf_Tell</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf)</td></tr>
<tr class="memdesc:a74100a089e88487f1fbfc66a4eb6b615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current position in input buffer.  <br /></td></tr>
<tr class="separator:a74100a089e88487f1fbfc66a4eb6b615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c61194f333fbb8914370b93af907e31" id="r_a3c61194f333fbb8914370b93af907e31"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c61194f333fbb8914370b93af907e31">UsefulInputBuf_Seek</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf, size_t uPos)</td></tr>
<tr class="memdesc:a3c61194f333fbb8914370b93af907e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current position in input buffer.  <br /></td></tr>
<tr class="separator:a3c61194f333fbb8914370b93af907e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b855fbc327bb5859a70a51489984414" id="r_a3b855fbc327bb5859a70a51489984414"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b855fbc327bb5859a70a51489984414">UsefulInputBuf_BytesUnconsumed</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf)</td></tr>
<tr class="memdesc:a3b855fbc327bb5859a70a51489984414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes from the cursor to the end of the buffer, the unconsumed bytes.  <br /></td></tr>
<tr class="separator:a3b855fbc327bb5859a70a51489984414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133e7c6d318aaf897678af4995335bd7" id="r_a133e7c6d318aaf897678af4995335bd7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a133e7c6d318aaf897678af4995335bd7">UsefulInputBuf_BytesAvailable</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf, size_t uLen)</td></tr>
<tr class="memdesc:a133e7c6d318aaf897678af4995335bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are unconsumed bytes.  <br /></td></tr>
<tr class="separator:a133e7c6d318aaf897678af4995335bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878e2ac99785be22c34ea94c606a44b2" id="r_a878e2ac99785be22c34ea94c606a44b2"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a878e2ac99785be22c34ea94c606a44b2">UsefulInputBuf_PointerToOffset</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf, const void *p)</td></tr>
<tr class="memdesc:a878e2ac99785be22c34ea94c606a44b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pointer to an offset with bounds checking.  <br /></td></tr>
<tr class="separator:a878e2ac99785be22c34ea94c606a44b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a315db2634f1ebb0963255aa66f98f2" id="r_a8a315db2634f1ebb0963255aa66f98f2"><td class="memItemLeft" align="right" valign="top">static const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a315db2634f1ebb0963255aa66f98f2">UsefulInputBuf_OffsetToPointer</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf, size_t uOffset)</td></tr>
<tr class="memdesc:a8a315db2634f1ebb0963255aa66f98f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an offset to a pointer with bounds checking.  <br /></td></tr>
<tr class="separator:a8a315db2634f1ebb0963255aa66f98f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4d98ccbb7306a3a770d17e6713871b" id="r_a4e4d98ccbb7306a3a770d17e6713871b"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e4d98ccbb7306a3a770d17e6713871b">UsefulInputBuf_GetBytes</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf, size_t uNum)</td></tr>
<tr class="memdesc:a4e4d98ccbb7306a3a770d17e6713871b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to bytes out of the input buffer.  <br /></td></tr>
<tr class="separator:a4e4d98ccbb7306a3a770d17e6713871b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bd6336074bfca7ee9919d1b0cfdd7c" id="r_a04bd6336074bfca7ee9919d1b0cfdd7c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04bd6336074bfca7ee9919d1b0cfdd7c">UsefulInputBuf_GetUsefulBuf</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf, size_t uNum)</td></tr>
<tr class="memdesc:a04bd6336074bfca7ee9919d1b0cfdd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> out of the input buffer.  <br /></td></tr>
<tr class="separator:a04bd6336074bfca7ee9919d1b0cfdd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12633b78dd38ffe126cb8ac79ee6efd4" id="r_a12633b78dd38ffe126cb8ac79ee6efd4"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12633b78dd38ffe126cb8ac79ee6efd4">UsefulInputBuf_GetByte</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf)</td></tr>
<tr class="memdesc:a12633b78dd38ffe126cb8ac79ee6efd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a byte out of the input buffer.  <br /></td></tr>
<tr class="separator:a12633b78dd38ffe126cb8ac79ee6efd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcb65971177f65b7bab9fd4ac499de6" id="r_a5dcb65971177f65b7bab9fd4ac499de6"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dcb65971177f65b7bab9fd4ac499de6">UsefulInputBuf_GetUint16</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf)</td></tr>
<tr class="memdesc:a5dcb65971177f65b7bab9fd4ac499de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <code>uint16_t</code> out of the input buffer.  <br /></td></tr>
<tr class="separator:a5dcb65971177f65b7bab9fd4ac499de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3276c0880ac251c18c5f5e9fcbe54169" id="r_a3276c0880ac251c18c5f5e9fcbe54169"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3276c0880ac251c18c5f5e9fcbe54169">UsefulInputBuf_GetUint32</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf)</td></tr>
<tr class="memdesc:a3276c0880ac251c18c5f5e9fcbe54169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <code>uint32_t</code> out of the input buffer.  <br /></td></tr>
<tr class="separator:a3276c0880ac251c18c5f5e9fcbe54169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1711958025316d9eaabade5e622d6c" id="r_a5d1711958025316d9eaabade5e622d6c"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d1711958025316d9eaabade5e622d6c">UsefulInputBuf_GetUint64</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf)</td></tr>
<tr class="memdesc:a5d1711958025316d9eaabade5e622d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <code>uint64_t</code> out of the input buffer.  <br /></td></tr>
<tr class="separator:a5d1711958025316d9eaabade5e622d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697e730ea4c27c94ba3509bc3150c3fe" id="r_a697e730ea4c27c94ba3509bc3150c3fe"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a697e730ea4c27c94ba3509bc3150c3fe">UsefulInputBuf_GetFloat</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf)</td></tr>
<tr class="memdesc:a697e730ea4c27c94ba3509bc3150c3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a float out of the input buffer.  <br /></td></tr>
<tr class="separator:a697e730ea4c27c94ba3509bc3150c3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a56f5430c754cfa22c8c9effa2556f" id="r_ad1a56f5430c754cfa22c8c9effa2556f"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1a56f5430c754cfa22c8c9effa2556f">UsefulInputBuf_GetDouble</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf)</td></tr>
<tr class="memdesc:ad1a56f5430c754cfa22c8c9effa2556f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a double out of the input buffer.  <br /></td></tr>
<tr class="separator:ad1a56f5430c754cfa22c8c9effa2556f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7771e7d2eb7f6825738b51f59bff5971" id="r_a7771e7d2eb7f6825738b51f59bff5971"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7771e7d2eb7f6825738b51f59bff5971">UsefulInputBuf_GetError</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf)</td></tr>
<tr class="memdesc:a7771e7d2eb7f6825738b51f59bff5971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the error status.  <br /></td></tr>
<tr class="separator:a7771e7d2eb7f6825738b51f59bff5971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d8437a4bdf451043c52e15b8a06d51" id="r_af4d8437a4bdf451043c52e15b8a06d51"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4d8437a4bdf451043c52e15b8a06d51">UsefulInputBuf_GetBufferLength</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf)</td></tr>
<tr class="memdesc:af4d8437a4bdf451043c52e15b8a06d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the input buffer length.  <br /></td></tr>
<tr class="separator:af4d8437a4bdf451043c52e15b8a06d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3074cca73dd828d5d60c7091e5ec7297" id="r_a3074cca73dd828d5d60c7091e5ec7297"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3074cca73dd828d5d60c7091e5ec7297">UsefulInputBuf_SetBufferLength</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf, size_t uNewLen)</td></tr>
<tr class="memdesc:a3074cca73dd828d5d60c7091e5ec7297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alters the input buffer length (use with caution).  <br /></td></tr>
<tr class="separator:a3074cca73dd828d5d60c7091e5ec7297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72435670de1194deb39c5cf80b518d2a" id="r_a72435670de1194deb39c5cf80b518d2a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72435670de1194deb39c5cf80b518d2a">UsefulInputBuf_RetrieveUndecodedInput</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf)</td></tr>
<tr class="memdesc:a72435670de1194deb39c5cf80b518d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the undecoded input buffer.  <br /></td></tr>
<tr class="separator:a72435670de1194deb39c5cf80b518d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb5546ed36a783b216934c44f37db55" id="r_a2cb5546ed36a783b216934c44f37db55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cb5546ed36a783b216934c44f37db55">UsefulInputBuf_Compare</a> (<a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *pUInBuf, const size_t uOffset1, const size_t uLen1, const size_t uOffset2, const size_t uLen2)</td></tr>
<tr class="memdesc:a2cb5546ed36a783b216934c44f37db55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two ranges of bytes somewhere in the input buffer.  <br /></td></tr>
<tr class="separator:a2cb5546ed36a783b216934c44f37db55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The goal of this code is to make buffer and pointer manipulation easier and safer when working with binary data.</p>
<p>The <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>, <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> and <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> structures are used to represent buffers rather than ad hoc pointers and lengths.</p>
<p>With these it is possible to write code that does little or no direct pointer manipulation for copying and formatting data. For example, the QCBOR encoder was written using these and has less pointer manipulation.</p>
<p>While it is true that object code using these functions will be a little larger and slower than a white-knuckle clever use of pointers might be, but not by that much or enough to have an effect for most use cases. For security-oriented code this is highly worthwhile. Clarity, simplicity, reviewability and are more important.</p>
<p>There are some extra sanity and double checks in this code to help catch coding errors and simple memory corruption. They are helpful, but not a substitute for proper code review, input validation and such.</p>
<p>This code consists of a lot of inline functions and a few that are not. It should not generate very much object code, especially with the optimizer turned up to <code>-Os</code> or <code>-O3</code>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9eabda18ec4acfa382b7a805a86f2189" name="a9eabda18ec4acfa382b7a805a86f2189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eabda18ec4acfa382b7a805a86f2189">&#9670;&#160;</a></span>ByteArrayLiteralToUsefulBufC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ByteArrayLiteralToUsefulBufC</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pBytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">   <a class="code hl_define" href="#aacc60f139ca7be95de2de18e5ea966ee">UsefulBuf_FROM_BYTE_ARRAY_LITERAL</a>(pBytes)</div>
<div class="ttc" id="a_useful_buf_8h_html_aacc60f139ca7be95de2de18e5ea966ee"><div class="ttname"><a href="#aacc60f139ca7be95de2de18e5ea966ee">UsefulBuf_FROM_BYTE_ARRAY_LITERAL</a></div><div class="ttdeci">#define UsefulBuf_FROM_BYTE_ARRAY_LITERAL(pBytes)</div><div class="ttdef"><b>Definition</b> UsefulBuf.h:461</div></div>
</div><!-- fragment --><p>Deprecated macro; use <a class="el" href="#aacc60f139ca7be95de2de18e5ea966ee">UsefulBuf_FROM_BYTE_ARRAY_LITERAL</a> instead </p>

</div>
</div>
<a id="acb8bfa82f56a0471331d2c4adaacfb61" name="acb8bfa82f56a0471331d2c4adaacfb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8bfa82f56a0471331d2c4adaacfb61">&#9670;&#160;</a></span>MakeUsefulBufOnStack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MakeUsefulBufOnStack</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    uint8_t    __pBuf##name[(size)];\</div>
<div class="line">    <a class="code hl_struct" href="structq__useful__buf.html">UsefulBuf</a>  name = {__pBuf##name , <span class="keyword">sizeof</span>( __pBuf##name )}</div>
<div class="ttc" id="astructq__useful__buf_html"><div class="ttname"><a href="structq__useful__buf.html">q_useful_buf</a></div><div class="ttdef"><b>Definition</b> UsefulBuf.h:291</div></div>
</div><!-- fragment --><p>Deprecated macro; use UsefulBuf_MAKE_STACK_UB instead </p>

</div>
</div>
<a id="ac590bc10c66f484fe139b361fe01c339" name="ac590bc10c66f484fe139b361fe01c339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac590bc10c66f484fe139b361fe01c339">&#9670;&#160;</a></span>NULLUsefulBuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NULLUsefulBuf&#160;&#160;&#160;((<a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>) {NULL, 0})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A null <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is one that has no memory associated the same way <code>NULL</code> points to nothing. It does not matter what <code>len</code> is. </p>

</div>
</div>
<a id="aef281b38ce49e9413dad0893d225c70d" name="aef281b38ce49e9413dad0893d225c70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef281b38ce49e9413dad0893d225c70d">&#9670;&#160;</a></span>NULLUsefulBufC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NULLUsefulBufC&#160;&#160;&#160;((<a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>) {NULL, 0})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A null <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> is one that has no value in the same way a <code>NULL</code> pointer has no value. A <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> is <code>NULL</code> when the <code>ptr</code> field is <code>NULL</code>. It doesn't matter what <code>len</code> is. See <a class="el" href="#af571fcde9e6463bfef16b30e2cd76c1f" title="Check if a UsefulBuf is empty or not.">UsefulBuf_IsEmpty()</a> for the distinction between null and empty. </p>

</div>
</div>
<a id="a7b4919809b569fd7fc5ead3fa926c9de" name="a7b4919809b569fd7fc5ead3fa926c9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4919809b569fd7fc5ead3fa926c9de">&#9670;&#160;</a></span>SizeCalculateUsefulBuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SizeCalculateUsefulBuf&#160;&#160;&#160;((<a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>) {NULL, SIZE_MAX})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> value that can be passed to <a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31" title="Initialize and supply the output buffer.">UsefulOutBuf_Init()</a> to have it calculate the size of the output buffer needed. Pass this for <code>Storage</code>, call all the append and insert functions normally, then call <a class="el" href="#a08eb02690d07e40dfdda3286bc332dbf" title="Returns the data put into a UsefulOutBuf.">UsefulOutBuf_OutUBuf()</a>. The returned <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> has the size.</p>
<p>As one can see, this is just a NULL pointer and very large size. The NULL pointer tells <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> to not copy any data. </p>

</div>
</div>
<a id="a22233f9d4579def61e77b006a78469ea" name="a22233f9d4579def61e77b006a78469ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22233f9d4579def61e77b006a78469ea">&#9670;&#160;</a></span>SZLiteralToUsefulBufC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SZLiteralToUsefulBufC</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>szString</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="#a778543dc5c8297cbfdc8b1716ebce423">UsefulBuf_FROM_SZ_LITERAL</a>(szString)</div>
<div class="ttc" id="a_useful_buf_8h_html_a778543dc5c8297cbfdc8b1716ebce423"><div class="ttname"><a href="#a778543dc5c8297cbfdc8b1716ebce423">UsefulBuf_FROM_SZ_LITERAL</a></div><div class="ttdeci">#define UsefulBuf_FROM_SZ_LITERAL(szString)</div><div class="ttdef"><b>Definition</b> UsefulBuf.h:447</div></div>
</div><!-- fragment --><p>Deprecated macro; use <a class="el" href="#a778543dc5c8297cbfdc8b1716ebce423">UsefulBuf_FROM_SZ_LITERAL</a> instead </p>

</div>
</div>
<a id="af1e8acba0f0d344d630494c9bd76ec7b" name="af1e8acba0f0d344d630494c9bd76ec7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e8acba0f0d344d630494c9bd76ec7b">&#9670;&#160;</a></span>UIB_MAGIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UIB_MAGIC&#160;&#160;&#160;(0xB00F)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The actual value of <code>magic</code> in UsefulInputBuf. </p>

</div>
</div>
<a id="a98eb36e1bdeab13b58d8a077d26bee86" name="a98eb36e1bdeab13b58d8a077d26bee86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98eb36e1bdeab13b58d8a077d26bee86">&#9670;&#160;</a></span>UsefulBuf_FROM_BYTE_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UsefulBuf_FROM_BYTE_ARRAY</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pBytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">   ((<a class="code hl_typedef" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>) {(pBytes), <span class="keyword">sizeof</span>(pBytes)})</div>
<div class="ttc" id="a_useful_buf_8h_html_a28f72e9ae0a9419e46735e16f8c2f449"><div class="ttname"><a href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></div><div class="ttdeci">struct q_useful_buf UsefulBuf</div></div>
</div><!-- fragment --><p>Make a byte array in to a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>. This is usually used on stack variables or static variables. Also see <a class="el" href="#ace69a6220419dd9dc204770c5b87efb6">UsefulBuf_MAKE_STACK_UB</a>. </p>

</div>
</div>
<a id="aacc60f139ca7be95de2de18e5ea966ee" name="aacc60f139ca7be95de2de18e5ea966ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc60f139ca7be95de2de18e5ea966ee">&#9670;&#160;</a></span>UsefulBuf_FROM_BYTE_ARRAY_LITERAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UsefulBuf_FROM_BYTE_ARRAY_LITERAL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pBytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">   ((<a class="code hl_typedef" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>) {(pBytes), <span class="keyword">sizeof</span>(pBytes)})</div>
<div class="ttc" id="a_useful_buf_8h_html_ad5ebb3732bd85ff732cc817fc280cc64"><div class="ttname"><a href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></div><div class="ttdeci">struct q_useful_buf_c UsefulBufC</div></div>
</div><!-- fragment --><p>Convert a literal byte array to a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>.</p>
<p><code>pBytes</code> must be a literal string that <code>sizeof()</code> works on. It will not work on non-literal arrays. </p>

</div>
</div>
<a id="a778543dc5c8297cbfdc8b1716ebce423" name="a778543dc5c8297cbfdc8b1716ebce423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778543dc5c8297cbfdc8b1716ebce423">&#9670;&#160;</a></span>UsefulBuf_FROM_SZ_LITERAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UsefulBuf_FROM_SZ_LITERAL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>szString</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((<a class="code hl_typedef" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>) {(szString), <span class="keyword">sizeof</span>(szString)-1})</div>
</div><!-- fragment --><p>Convert a literal string to a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>.</p>
<p><code>szString</code> must be a literal string that <code>sizeof()</code> works on. This is better for literal strings than <a class="el" href="#a29f51e2194792e98be0a0192579e3e2b" title="Convert a NULL-terminated string to a UsefulBufC.">UsefulBuf_FromSZ()</a> because it generates less code. It will not work on non-literal strings.</p>
<p>The terminating \0 (NULL) is NOT included in the length! </p>

</div>
</div>
<a id="ace69a6220419dd9dc204770c5b87efb6" name="ace69a6220419dd9dc204770c5b87efb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace69a6220419dd9dc204770c5b87efb6">&#9670;&#160;</a></span>UsefulBuf_MAKE_STACK_UB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UsefulBuf_MAKE_STACK_UB</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    uint8_t    __pBuf##name[(size)];\</div>
<div class="line">    <a class="code hl_struct" href="structq__useful__buf.html">UsefulBuf</a>  name = {__pBuf##name , <span class="keyword">sizeof</span>( __pBuf##name )}</div>
</div><!-- fragment --><p>Make an automatic variable named <code>name</code> of type <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> and point it to a stack variable of the given <code>size</code>. </p>

</div>
</div>
<a id="ad3255da9088f245f9662f522758be3fb" name="ad3255da9088f245f9662f522758be3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3255da9088f245f9662f522758be3fb">&#9670;&#160;</a></span>UsefulBufC_NTH_BYTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UsefulBufC_NTH_BYTE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>UBC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((<span class="keyword">const</span> uint8_t *)(UBC.ptr))[n])</div>
</div><!-- fragment -->
<p>Get the nth byte from a UsefulBufC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UBC</td><td>UsefulBufC from which to get byte </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Index of byte to get</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: this doesn't check that <code>is</code> within the UsefulBufC. This point of this is to have the ugly cast in just one place. </p>

</div>
</div>
<a id="a54fed8f0b3943666846bae738004dfbe" name="a54fed8f0b3943666846bae738004dfbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fed8f0b3943666846bae738004dfbe">&#9670;&#160;</a></span>UsefulOutBuf_MakeOnStack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UsefulOutBuf_MakeOnStack</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">   uint8_t       __pBuf##name[(size)];\</div>
<div class="line">   <a class="code hl_struct" href="structuseful__out__buf.html">UsefulOutBuf</a>  name;\</div>
<div class="line">   UsefulOutBuf_Init(&amp;(name), (<a class="code hl_struct" href="structq__useful__buf.html">UsefulBuf</a>){__pBuf##name, (size)});</div>
<div class="ttc" id="astructuseful__out__buf_html"><div class="ttname"><a href="structuseful__out__buf.html">useful_out_buf</a></div><div class="ttdef"><b>Definition</b> UsefulBuf.h:875</div></div>
</div><!-- fragment --><p>Convenience macro to make a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> on the stack and initialize it with a stack buffer of the given size. The variable will be named <code>name</code>. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a28f72e9ae0a9419e46735e16f8c2f449" name="a28f72e9ae0a9419e46735e16f8c2f449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f72e9ae0a9419e46735e16f8c2f449">&#9670;&#160;</a></span>UsefulBuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structq__useful__buf.html">q_useful_buf</a> <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This non-const <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is typically used for some allocated memory that is to be filled in. The <code>len</code> is the amount of memory, not the length of the valid data in the buffer. </p>

</div>
</div>
<a id="ad5ebb3732bd85ff732cc817fc280cc64" name="ad5ebb3732bd85ff732cc817fc280cc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ebb3732bd85ff732cc817fc280cc64">&#9670;&#160;</a></span>UsefulBufC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structq__useful__buf__c.html">q_useful_buf_c</a> <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> and <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> are simple data structures to hold a pointer and length for binary data. In C99 this data structure can be passed on the stack making a lot of code cleaner than carrying around a pointer and length as two parameters.</p>
<p>This is also conducive to secure coding practice as the length is always carried with the pointer and the convention for handling a pointer and a length is clear.</p>
<p>While it might be possible to write buffer and pointer code more efficiently in some use cases, the thought is that unless there is an extreme need for performance (e.g., you are building a gigabit-per-second IP router), it is probably better to have cleaner code you can be most certain about the security of.</p>
<p>The non-const <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is usually used to refer an empty buffer to be filled in. The length is the size of the buffer.</p>
<p>The const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> is usually used to refer to some data that has been filled in. The length is amount of valid data pointed to.</p>
<p>A common use mode is to pass a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> to a function, the function puts some data in it, then the function returns a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> refering to the data. The <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is a non-const "in" parameter and the <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> is a const "out" parameter so the constness stays correct. There is no single "in,out" parameter (if there was, it would have to be non-const). Note that the pointer returned in the <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> usually ends up being the same pointer passed in as a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>, though this is not striclty required.</p>
<p>A <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is null, it has no value, when <code>ptr</code> in it is <code>NULL</code>.</p>
<p>There are functions and macros for the following:</p><ul>
<li>Initializing</li>
<li>Create initialized const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> from compiler literals</li>
<li>Create initialized const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> from NULL-terminated string</li>
<li>Make an empty <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> on the stack</li>
<li>Checking whether a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is null, empty or both</li>
<li>Copying, copying with offset, copying head or tail</li>
<li>Comparing and finding substrings</li>
</ul>
<p>See also <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. It is a richer structure that has both the size of the valid data and the size of the buffer.</p>
<p><a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is only 16 or 8 bytes on a 64- or 32-bit machine so it can go on the stack and be a function parameter or return value.</p>
<p>Another way to look at it is this. C has the NULL-terminated string as a means for handling text strings, but no means or convention for binary strings. Other languages do have such means, Rust, an efficient compiled language, for example.</p>
<p><a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is kind of like the Useful Pot Pooh gave Eeyore on his birthday. Eeyore's balloon fits beautifully, "it goes in and
out like anything". </p>

</div>
</div>
<a id="a40147dc1c6e6ab03d7690b195b21603f" name="a40147dc1c6e6ab03d7690b195b21603f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40147dc1c6e6ab03d7690b195b21603f">&#9670;&#160;</a></span>UsefulInputBuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structuseful__input__buf.html">useful_input_buf</a> <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> is the counterpart to <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. It is for parsing data received. Initialize it with the data from the network. Then use the functions like <a class="el" href="#a4e4d98ccbb7306a3a770d17e6713871b" title="Get pointer to bytes out of the input buffer.">UsefulInputBuf_GetBytes()</a> to get data chunks of various types. A position cursor is maintained internally.</p>
<p>As long as the functions here are used, there will never be any reference off the end of the given buffer (except <a class="el" href="#a3074cca73dd828d5d60c7091e5ec7297" title="Alters the input buffer length (use with caution).">UsefulInputBuf_SetBufferLength()</a>). This is true even if they are called incorrectly, an attempt is made to seek off the end of the buffer or such. This makes it easier to write safe and correct code. For example, the QCBOR decoder implementation is safer and easier to review through its use of <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>.</p>
<p><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> maintains an internal error state. The intended use is fetching data chunks without any error checks until the end. If there was any error, such as an attempt to fetch data off the end, the error state is entered and no further data will be returned. In the error state the <code>UsefulInputBuf_GetXxxx()</code> functions return 0, or <code>NULL</code> or <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a>. As long as null is not dereferenced, the error check can be put off until the end, simplifying the calling code.</p>
<p>The integer and float parsing expects network byte order (big endian). Network byte order is what is used by TCP/IP, CBOR and most internet protocols.</p>
<p>Lots of inline functions are used to keep code size down. The optimizer, particularly with the <code>-Os</code> or <code>-O3</code>, also reduces code size a lot. The only non-inline code is <a class="el" href="#a4e4d98ccbb7306a3a770d17e6713871b" title="Get pointer to bytes out of the input buffer.">UsefulInputBuf_GetBytes()</a>. It is less than 100 bytes so use of <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> doesn't add much code for all the messy hard-to-get right issues with parsing binary protocols in C that it solves.</p>
<p>The parse context size is:</p><ul>
<li>64-bit machine: 16 + 8 + 2 + 1 (+ 5 bytes padding to align) = 32 bytes</li>
<li>32-bit machine: 8 + 4 + 2 + 1 (+ 1 byte padding to align) = 16 bytes </li>
</ul>

</div>
</div>
<a id="a83f01ed9a781335a27e651b4d0fe99cd" name="a83f01ed9a781335a27e651b4d0fe99cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f01ed9a781335a27e651b4d0fe99cd">&#9670;&#160;</a></span>UsefulOutBuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structuseful__out__buf.html">useful_out_buf</a> <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UsefulOutBuf is a structure and functions (an object) for serializing data into a buffer to encode for a network protocol or write data to a file.</p>
<p>The main idea is that all the pointer manipulation is performed by <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> functions so the caller doesn't have to do any pointer manipulation. The pointer manipulation is centralized. This code has been reviewed and written carefully so it spares the caller of much of this work and results in safer code with less effort.</p>
<p>The <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> methods that add data to the output buffer always check the length and will never write off the end of the output buffer. If an attempt to add data that will not fit is made, an internal error flag will be set and further attempts to add data will not do anything.</p>
<p>There is no way to ever write off the end of that buffer when calling the <code>UsefulOutBuf_AddXxx()</code> and <code>UsefulOutBuf_InsertXxx()</code> functions.</p>
<p>The functions to add data do not report success of failure. The caller only needs to check for an error in the final call, either <a class="el" href="#a08eb02690d07e40dfdda3286bc332dbf" title="Returns the data put into a UsefulOutBuf.">UsefulOutBuf_OutUBuf()</a> or <a class="el" href="#a282b65088cb6f2f39c01edfbd06ca5a1" title="Copy out the data put into a UsefulOutBuf.">UsefulOutBuf_CopyOut()</a> to get the result. This makes the calling code cleaner.</p>
<p>There is a utility function to get the error status anytime along the way for a special circumstance. There are functions to see how much room is left and see if some data will fit too, but their use is generally unnecessary.</p>
<p>The general call flow is:</p>
<ul>
<li>Initialize by calling <a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31">UsefulOutBuf_Init()</a>. The output buffer given to it can be from the heap, stack or otherwise. <a class="el" href="#a54fed8f0b3943666846bae738004dfbe">UsefulOutBuf_MakeOnStack</a> is a convenience macro that makes a buffer on the stack and initializes it.</li>
<li>Call methods like <a class="el" href="#a14baa7dec0d821f7069a74de20d86ce4" title="Insert a NULL-terminated string into the UsefulOutBuf.">UsefulOutBuf_InsertString()</a>, <a class="el" href="#a6ac934b99c15fc41c92d3197a2af6b19" title="Append an integer to the UsefulOutBuf.">UsefulOutBuf_AppendUint32()</a> and <a class="el" href="#a09ea2a68453e34fea416d52017b4b37c" title="Inserts bytes into the UsefulOutBuf.">UsefulOutBuf_InsertUsefulBuf()</a> to output data. The append calls add data to the end of the valid data. The insert calls take a position argument.</li>
<li>Call <a class="el" href="#a08eb02690d07e40dfdda3286bc332dbf" title="Returns the data put into a UsefulOutBuf.">UsefulOutBuf_OutUBuf()</a> or <a class="el" href="#a282b65088cb6f2f39c01edfbd06ca5a1" title="Copy out the data put into a UsefulOutBuf.">UsefulOutBuf_CopyOut()</a> to see there were no errors and to get the serialized output bytes.</li>
</ul>
<p><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> can be used in a mode to calculate the size of what would be output without actually outputting anything. This is useful to calculate the size of a buffer that is to be allocated to hold the output. See <a class="el" href="#a7b4919809b569fd7fc5ead3fa926c9de">SizeCalculateUsefulBuf</a>.</p>
<p>Methods like <a class="el" href="#ae85576eaefd482c7e6ee9483914f63af" title="Insert a 64-bit integer into the UsefulOutBuf.">UsefulOutBuf_InsertUint64()</a> always output in network byte order (big endian).</p>
<p>The possible errors are:</p>
<ul>
<li>The <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> was not initialized or was corrupted.</li>
<li>An attempt was made to add data that will not fit.</li>
<li>An attempt was made to insert data at a position beyond the end of the buffer.</li>
<li>An attempt was made to insert data at a position beyond the valid data in the buffer.</li>
</ul>
<p>Some inexpensive simple sanity checks are performed before every data addition to guard against use of an uninitialized or corrupted UsefulOutBuf.</p>
<p><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> has been used to create a CBOR encoder. The CBOR encoder has almost no pointer manipulation in it, is easier to read, and easier to review.</p>
<p>A <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> is small and can go on the stack:</p><ul>
<li>32 bytes (27 bytes plus alignment padding) on a 64-bit CPU</li>
<li>16 bytes (15 bytes plus alignment padding) on a 32-bit CPU </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab57b19dfa682d1806296f891bee01693" name="ab57b19dfa682d1806296f891bee01693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57b19dfa682d1806296f891bee01693">&#9670;&#160;</a></span>UsefulBuf_Compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UsefulBuf_Compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UB1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UB2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare one <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB1</td><td>The first buffer to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UB2</td><td>The second buffer to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0, positive or negative value.</dd></dl>
<p>Returns a negative value if <code>UB1</code> if is less than <code>UB2</code>. <code>UB1</code> is less than <code>UB2</code> if it is shorter or the first byte that is not the same is less.</p>
<p>Returns 0 if the inputs are the same.</p>
<p>Returns a positive value if <code>UB2</code> is less than <code>UB1</code>.</p>
<p>All that is of significance is that the result is positive, negative or 0. (This doesn't return the difference between the first non-matching byte like <code>memcmp()</code> ). </p>

</div>
</div>
<a id="ad1b9924b51c67d6363fae93c0c6b4a95" name="ad1b9924b51c67d6363fae93c0c6b4a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b9924b51c67d6363fae93c0c6b4a95">&#9670;&#160;</a></span>UsefulBuf_Const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulBuf_Const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>UB</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a non-const <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> to a const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>The <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> struct. </dd></dl>

</div>
</div>
<a id="acb4fb99a895e5384d30814ca07756777" name="acb4fb99a895e5384d30814ca07756777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4fb99a895e5384d30814ca07756777">&#9670;&#160;</a></span>UsefulBuf_Copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulBuf_Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>Dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>Src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy one <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> into another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Dest</td><td>The destination buffer to copy into. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Src</td><td>The source to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filled in <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> on success, <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> on failure.</dd></dl>
<p>This fails if <code>Src.len</code> is greater than <code>Dest.len</code>.</p>
<p>Note that like <code>memcpy()</code>, the pointers are not checked and this will crash rather than return <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> if they are <code>NULL</code> or invalid.</p>
<p>The results are undefined if <code>Dest</code> and <code>Src</code> overlap. </p>

</div>
</div>
<a id="a82cbe966444cc482aaeef036ae801ebd" name="a82cbe966444cc482aaeef036ae801ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cbe966444cc482aaeef036ae801ebd">&#9670;&#160;</a></span>UsefulBuf_CopyOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulBuf_CopyOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>Dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>Src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy one <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> into another at an offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Dest</td><td>Destination buffer to copy into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uOffset</td><td>The byte offset in <code>Dest</code> at which to copy to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Src</td><td>The bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer and length of the copy or <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a>.</dd></dl>
<p>This fails and returns <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> if <code>offset</code> is beyond the size of <code>Dest</code>.</p>
<p>This fails and returns <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> if the <code>Src</code> length plus <code>uOffset</code> is greater than the length of <code>Dest</code>.</p>
<p>The results are undefined if <code>Dest</code> and <code>Src</code> overlap.</p>
<p>This assumes that there is valid data in <code>Dest</code> up to <code>uOffset</code>. The <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> returned starts at the beginning of <code>Dest</code> and goes to <code>Src.len</code> <code>+</code> <code>uOffset</code>. </p>

</div>
</div>
<a id="a5424debf4c272ca43654d4f1a65173aa" name="a5424debf4c272ca43654d4f1a65173aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5424debf4c272ca43654d4f1a65173aa">&#9670;&#160;</a></span>UsefulBuf_CopyPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulBuf_CopyPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>Dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uLen</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a pointer into a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Dest</td><td>The destination buffer to copy into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The source to copy from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uLen</td><td>Length of the source; amount to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filled in <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> on success, <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> on failure.</dd></dl>
<p>This fails and returns <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> if <code>uLen</code> is greater than <code>pDest-&gt;len</code>.</p>
<p>Note that like <code>memcpy()</code>, the pointers are not checked and this will crash, rather than return 1 if they are <code>NULL</code> or invalid. </p>

</div>
</div>
<a id="a08a028eb81150d93fc1fc83b1ea7ac6b" name="a08a028eb81150d93fc1fc83b1ea7ac6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a028eb81150d93fc1fc83b1ea7ac6b">&#9670;&#160;</a></span>UsefulBuf_FindBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UsefulBuf_FindBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>BytesToSearch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>BytesToFind</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find one <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> in another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesToSearch</td><td>Buffer to search through. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BytesToFind</td><td>Buffer with bytes to be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of found bytes or <code>SIZE_MAX</code> if not found. </dd></dl>

</div>
</div>
<a id="a29f51e2194792e98be0a0192579e3e2b" name="a29f51e2194792e98be0a0192579e3e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f51e2194792e98be0a0192579e3e2b">&#9670;&#160;</a></span>UsefulBuf_FromSZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulBuf_FromSZ </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szString</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a NULL-terminated string to a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">szString</td><td>The string to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> struct.</dd></dl>
<p><code>UsefulBufC.ptr</code> points to the string so its lifetime must be maintained.</p>
<p>The terminating \0 (NULL) is NOT included in the length. </p>

</div>
</div>
<a id="ad8a21703d4dac011f8ecb3f695ee3c59" name="ad8a21703d4dac011f8ecb3f695ee3c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a21703d4dac011f8ecb3f695ee3c59">&#9670;&#160;</a></span>UsefulBuf_Head()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulBuf_Head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uAmount</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a truncation of a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>The buffer to get the head of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uAmount</td><td>The number of bytes in the head.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> that is the head of UB. </dd></dl>

</div>
</div>
<a id="af571fcde9e6463bfef16b30e2cd76c1f" name="af571fcde9e6463bfef16b30e2cd76c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af571fcde9e6463bfef16b30e2cd76c1f">&#9670;&#160;</a></span>UsefulBuf_IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int UsefulBuf_IsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>UB</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is empty or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>The <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if it is empty, 0 if not.</dd></dl>
<p>An "empty" <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is one that has a value and can be considered to be set, but that value is of zero length. It is empty when <code>len</code> is zero. It doesn't matter what the <code>ptr</code> is.</p>
<p>Many uses will not need to clearly distinguish a <code>NULL</code> <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> from an empty one and can have the <code>ptr</code> <code>NULL</code> and the <code>len</code> 0. However if a use of <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> needs to make a distinction then <code>ptr</code> should not be <code>NULL</code> when the <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is considered empty, but not <code>NULL</code>. </p>

</div>
</div>
<a id="a64e21918b707e90e5a8af563eaaa1c5d" name="a64e21918b707e90e5a8af563eaaa1c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e21918b707e90e5a8af563eaaa1c5d">&#9670;&#160;</a></span>UsefulBuf_IsEmptyC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int UsefulBuf_IsEmptyC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UB</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> is empty or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>The <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if it is empty, 0 if not. </dd></dl>

</div>
</div>
<a id="a682553796f9ce5361bc9a70d4347444d" name="a682553796f9ce5361bc9a70d4347444d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682553796f9ce5361bc9a70d4347444d">&#9670;&#160;</a></span>UsefulBuf_IsNULL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int UsefulBuf_IsNULL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>UB</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is <a class="el" href="#ac590bc10c66f484fe139b361fe01c339">NULLUsefulBuf</a> or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>The UsefulBuf to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if it is <a class="el" href="#ac590bc10c66f484fe139b361fe01c339">NULLUsefulBuf</a>, 0 if not. </dd></dl>

</div>
</div>
<a id="a5bfed827589d6ed9f53a650ddd58b58a" name="a5bfed827589d6ed9f53a650ddd58b58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfed827589d6ed9f53a650ddd58b58a">&#9670;&#160;</a></span>UsefulBuf_IsNULLC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int UsefulBuf_IsNULLC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UB</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> is <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>The <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if it is <code>NULLUsefulBufC</code>, 0 if not. </dd></dl>

</div>
</div>
<a id="aeae9f4782b8555340d73e8d63ec2691e" name="aeae9f4782b8555340d73e8d63ec2691e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae9f4782b8555340d73e8d63ec2691e">&#9670;&#160;</a></span>UsefulBuf_IsNULLOrEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int UsefulBuf_IsNULLOrEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>UB</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is <a class="el" href="#ac590bc10c66f484fe139b361fe01c339">NULLUsefulBuf</a> or empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>The <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if it is either <a class="el" href="#ac590bc10c66f484fe139b361fe01c339">NULLUsefulBuf</a> or empty, 0 if not. </dd></dl>

</div>
</div>
<a id="aca503e3b347234429acf80e460e31cdd" name="aca503e3b347234429acf80e460e31cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca503e3b347234429acf80e460e31cdd">&#9670;&#160;</a></span>UsefulBuf_IsNULLOrEmptyC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int UsefulBuf_IsNULLOrEmptyC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UB</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> is <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> or empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>The <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if it is either <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> or empty, 0 if not. </dd></dl>

</div>
</div>
<a id="aa15cfdf544b8f3cf7b42351f0b3d7ad3" name="aa15cfdf544b8f3cf7b42351f0b3d7ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15cfdf544b8f3cf7b42351f0b3d7ad3">&#9670;&#160;</a></span>UsefulBuf_IsValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UsefulBuf_IsValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>uValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find first byte that is not a particular byte value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>The destination buffer for byte comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uValue</td><td>The byte value to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Offset of first byte that isn't <code>uValue</code> or <code>SIZE_MAX</code> if all bytes are <code>uValue</code>.</dd></dl>
<p>Note that unlike most comparison functions, 0 does not indicate a successful comparison, so the test for match is: </p><pre class="fragment"> UsefulBuf_IsValue(...) == SIZE_MAX
</pre><p>If <code>UB</code> is null or empty, there is no match and 0 is returned. </p>

</div>
</div>
<a id="a92870bf6b3632564213eb3f877c55a85" name="a92870bf6b3632564213eb3f877c55a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92870bf6b3632564213eb3f877c55a85">&#9670;&#160;</a></span>UsefulBuf_OffsetToPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const void * UsefulBuf_OffsetToPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uOffset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an offset to a pointer with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>A UsefulBuf. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uOffset</td><td>Offset in <code>pUInBuf</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>NULL</code> if <code>uOffset</code> is out of range, a pointer into the buffer if not. </dd></dl>

</div>
</div>
<a id="a413d8a142633d8b061d2639063c840fb" name="a413d8a142633d8b061d2639063c840fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413d8a142633d8b061d2639063c840fb">&#9670;&#160;</a></span>UsefulBuf_PointerToOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t UsefulBuf_PointerToOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a pointer to an offset with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>A UsefulBuf. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to convert to offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIZE_MAX if <code>p</code> is out of range, the byte offset if not. </dd></dl>

</div>
</div>
<a id="a71f9265753384286f3a1aaf394f00bf7" name="a71f9265753384286f3a1aaf394f00bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f9265753384286f3a1aaf394f00bf7">&#9670;&#160;</a></span>UsefulBuf_Set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulBuf_Set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>pDest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all bytes in a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> to a value, for example to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDest</td><td>The destination buffer to copy into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to set the bytes to.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that like <code>memset()</code>, the pointer in <code>pDest</code> is not checked and this will crash if <code>NULL</code> or invalid. </p>

</div>
</div>
<a id="aa42353fc50fa085d44d28e3fb5dcf7f4" name="aa42353fc50fa085d44d28e3fb5dcf7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42353fc50fa085d44d28e3fb5dcf7f4">&#9670;&#160;</a></span>UsefulBuf_SkipLeading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulBuf_SkipLeading </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>String</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>uByte</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip leading bytes of a particular value in a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">String</td><td>The input string. String.ptr must not be <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uByte</td><td>The byte value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring with leading bytes with value <code>uByte</code> removed. </dd></dl>

</div>
</div>
<a id="adaceb62d7b73b18be451c06a5d2540e5" name="adaceb62d7b73b18be451c06a5d2540e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaceb62d7b73b18be451c06a5d2540e5">&#9670;&#160;</a></span>UsefulBuf_Tail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulBuf_Tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uAmount</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns bytes from the end of a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>The buffer to get the tail of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uAmount</td><td>The offset from the start where the tail is to begin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> that is the tail of <code>UB</code> or <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> if <code>uAmount</code> is greater than the length of the <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>.</dd></dl>
<p>If <code>UB.ptr</code> is <code>NULL</code>, but <code>UB.len</code> is not zero, then the result will be a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> with a <code>NULL</code> <code>ptr</code> and <code>len</code> with the length of the tail. </p>

</div>
</div>
<a id="a12d237545f02c630dc59d1d9a4540df1" name="a12d237545f02c630dc59d1d9a4540df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d237545f02c630dc59d1d9a4540df1">&#9670;&#160;</a></span>UsefulBuf_Unconst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> UsefulBuf_Unconst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UBC</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> to a non-const <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UBC</td><td>The <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-const <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> struct.</dd></dl>
<p>Use of this is not necessary for the intended use mode of <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> and <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>. In that mode, the <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> is created to describe a buffer that has not had any data put in it. Then the data is put in it. Then a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> is create to describe the part with the data in it. This goes from non-const to const, so this function is not needed.</p>
<p>If the -Wcast-qual warning is enabled, this function can be used to avoid that warning. </p>

</div>
</div>
<a id="a7b8f5b0328bb3a5575e7d726e4499f71" name="a7b8f5b0328bb3a5575e7d726e4499f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8f5b0328bb3a5575e7d726e4499f71">&#9670;&#160;</a></span>UsefulBufC_Unconst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> UsefulBufC_Unconst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UBC</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deprecated function; use <a class="el" href="#a12d237545f02c630dc59d1d9a4540df1" title="Convert a const UsefulBufC to a non-const UsefulBuf.">UsefulBuf_Unconst()</a> instead </p>

</div>
</div>
<a id="a728daeea6ec716b8a444d96b281ecd5f" name="a728daeea6ec716b8a444d96b281ecd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728daeea6ec716b8a444d96b281ecd5f">&#9670;&#160;</a></span>UsefulBufUtil_CopyDoubleToUint64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t UsefulBufUtil_CopyDoubleToUint64 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a <code>double</code> to a <code>uint64_t</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>Double value to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>uint64_t</code> with the double bits.</dd></dl>
<p>Convenience function to avoid type punning, compiler warnings and such. The optimizer usually reduces this to a simple assignment. This is a crusty corner of C. </p>

</div>
</div>
<a id="a3f4e7c2dc2a448f714b95c6440fc81cb" name="a3f4e7c2dc2a448f714b95c6440fc81cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4e7c2dc2a448f714b95c6440fc81cb">&#9670;&#160;</a></span>UsefulBufUtil_CopyFloatToUint32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t UsefulBufUtil_CopyFloatToUint32 </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a <code>float</code> to a <code>uint32_t</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Float value to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>uint32_t</code> with the float bits.</dd></dl>
<p>Convenience function to avoid type punning, compiler warnings and such. The optimizer usually reduces this to a simple assignment. This is a crusty corner of C. </p>

</div>
</div>
<a id="a63eb31f1337f07b203260f598068ea1c" name="a63eb31f1337f07b203260f598068ea1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63eb31f1337f07b203260f598068ea1c">&#9670;&#160;</a></span>UsefulBufUtil_CopyUint32ToFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float UsefulBufUtil_CopyUint32ToFloat </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>u32</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a <code>uint32_t</code> to a <code>float</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u32</td><td>Integer value to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value as a <code>float</code>.</dd></dl>
<p>Convenience function to avoid type punning, compiler warnings and such. The optimizer usually reduces this to a simple assignment. This is a crusty corner of C. </p>

</div>
</div>
<a id="a9ab72301ac77d863027528333ae31152" name="a9ab72301ac77d863027528333ae31152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab72301ac77d863027528333ae31152">&#9670;&#160;</a></span>UsefulBufUtil_CopyUint64ToDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double UsefulBufUtil_CopyUint64ToDouble </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>u64</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a <code>uint64_t</code> to a <code>double</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u64</td><td>Integer value to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value as a <code>double</code>.</dd></dl>
<p>Convenience function to avoid type punning, compiler warnings and such. The optimizer usually reduces this to a simple assignment. This is a crusty corner of C. </p>

</div>
</div>
<a id="a133e7c6d318aaf897678af4995335bd7" name="a133e7c6d318aaf897678af4995335bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133e7c6d318aaf897678af4995335bd7">&#9670;&#160;</a></span>UsefulInputBuf_BytesAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int UsefulInputBuf_BytesAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uLen</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if there are unconsumed bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uLen</td><td>Number of bytes to check availability for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if <code>uLen</code> bytes are available after the cursor, and 0 if not. </dd></dl>

</div>
</div>
<a id="a3b855fbc327bb5859a70a51489984414" name="a3b855fbc327bb5859a70a51489984414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b855fbc327bb5859a70a51489984414">&#9670;&#160;</a></span>UsefulInputBuf_BytesUnconsumed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t UsefulInputBuf_BytesUnconsumed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes from the cursor to the end of the buffer, the unconsumed bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes unconsumed or 0 on error.</dd></dl>
<p>Returns 0 if the cursor is invalid or corruption of the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> structure is detected. </p>

</div>
</div>
<a id="a2cb5546ed36a783b216934c44f37db55" name="a2cb5546ed36a783b216934c44f37db55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb5546ed36a783b216934c44f37db55">&#9670;&#160;</a></span>UsefulInputBuf_Compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UsefulInputBuf_Compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>uOffset1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>uLen1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>uOffset2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>uLen2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two ranges of bytes somewhere in the input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>The input buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uOffset1</td><td>Offset of first range of bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uLen1</td><td>Length of first range of bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uOffset2</td><td>Offset of second range of bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uLen2</td><td>Length of second range of bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>This returns the same as <a class="el" href="#ab57b19dfa682d1806296f891bee01693" title="Compare one UsefulBufC to another.">UsefulBuf_Compare()</a>.</p>
<p>If the offset or the length plus offset or a range extends outside the input buffer, that range of bytes will be considered greater than the other string. If both are outside this is considered a degenerate condition and the first string is considered larger.</p>
<p>This is a somewhat odd function of UsefulInputBuf as it is not used for consuming data. QCBOR uses it for map order and duplicate checking. </p>

</div>
</div>
<a id="af4d8437a4bdf451043c52e15b8a06d51" name="af4d8437a4bdf451043c52e15b8a06d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d8437a4bdf451043c52e15b8a06d51">&#9670;&#160;</a></span>UsefulInputBuf_GetBufferLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t UsefulInputBuf_GetBufferLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the input buffer length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the input buffer.</dd></dl>
<p>This returns the length of the input buffer set by <a class="el" href="#a52d00cc7d9fc4fe1427cc43aeb3bfc35" title="Initialize the UsefulInputBuf structure before use.">UsefulInputBuf_Init()</a> or <a class="el" href="#a3074cca73dd828d5d60c7091e5ec7297" title="Alters the input buffer length (use with caution).">UsefulInputBuf_SetBufferLength()</a>. </p>

</div>
</div>
<a id="a12633b78dd38ffe126cb8ac79ee6efd4" name="a12633b78dd38ffe126cb8ac79ee6efd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12633b78dd38ffe126cb8ac79ee6efd4">&#9670;&#160;</a></span>UsefulInputBuf_GetByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t UsefulInputBuf_GetByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a byte out of the input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte.</dd></dl>
<p>This consumes 1 byte from the input buffer, returns it and advances the position cursor by 1.</p>
<p>If there is not 1 byte in the buffer, 0 will be returned for the byte and the error state is entered. To know if the 0 returned was in error or the real value, the error state must be checked. If possible, put this off until all values are retrieved to have smaller and simpler code, but if not possible <a class="el" href="#a7771e7d2eb7f6825738b51f59bff5971" title="Get the error status.">UsefulInputBuf_GetError()</a> can be called. Also, in the error state <a class="el" href="#a4e4d98ccbb7306a3a770d17e6713871b" title="Get pointer to bytes out of the input buffer.">UsefulInputBuf_GetBytes()</a> returns <code>NULL</code> *or the <code>ptr</code> from <a class="el" href="#a04bd6336074bfca7ee9919d1b0cfdd7c" title="Get UsefulBuf out of the input buffer.">UsefulInputBuf_GetUsefulBuf()</a> is <code>NULL</code>. </p>

</div>
</div>
<a id="a4e4d98ccbb7306a3a770d17e6713871b" name="a4e4d98ccbb7306a3a770d17e6713871b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4d98ccbb7306a3a770d17e6713871b">&#9670;&#160;</a></span>UsefulInputBuf_GetBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * UsefulInputBuf_GetBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uNum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to bytes out of the input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uNum</td><td>Number of bytes to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to bytes.</dd></dl>
<p>This consumes <code>uNum</code> bytes from the input buffer. This returns a pointer to the start of the <code>uNum</code> bytes.</p>
<p>If there are not <code>uNum</code> bytes in the input buffer, <code>NULL</code> will be returned and the error state is entered.</p>
<p>This advances the position cursor by <code>uNum</code> bytes. </p>

</div>
</div>
<a id="ad1a56f5430c754cfa22c8c9effa2556f" name="ad1a56f5430c754cfa22c8c9effa2556f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a56f5430c754cfa22c8c9effa2556f">&#9670;&#160;</a></span>UsefulInputBuf_GetDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double UsefulInputBuf_GetDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a double out of the input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The double.</dd></dl>
<p>See <a class="el" href="#a12633b78dd38ffe126cb8ac79ee6efd4" title="Get a byte out of the input buffer.">UsefulInputBuf_GetByte()</a>. This works the same, except it returns a double and eight bytes are consumed.</p>
<p>The input bytes are interpreted in network order (big endian). </p>

</div>
</div>
<a id="a7771e7d2eb7f6825738b51f59bff5971" name="a7771e7d2eb7f6825738b51f59bff5971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7771e7d2eb7f6825738b51f59bff5971">&#9670;&#160;</a></span>UsefulInputBuf_GetError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int UsefulInputBuf_GetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the error status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if not in the error state, 1 if in the error state.</dd></dl>
<p>This returns whether the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> is in the error state or not.</p>
<p>The error state is entered for one of these reasons:</p><ul>
<li>Attempt to fetch data past the end of the buffer</li>
<li>Attempt to seek to a position past the end of the buffer</li>
<li>Attempt to get data from an uninitialized or corrupt instance of <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a></li>
</ul>
<p>Once in the error state, it can only be cleared by calling <a class="el" href="#a52d00cc7d9fc4fe1427cc43aeb3bfc35" title="Initialize the UsefulInputBuf structure before use.">UsefulInputBuf_Init()</a>.</p>
<p>For many use cases, it is possible to only call this once after all the <code>UsefulInputBuf_GetXxxx()</code> calls have been made. This is possible if no reference to the data returned are needed before the error state is checked.</p>
<p>In some cases <a class="el" href="#a04bd6336074bfca7ee9919d1b0cfdd7c" title="Get UsefulBuf out of the input buffer.">UsefulInputBuf_GetUsefulBuf()</a> or <a class="el" href="#a4e4d98ccbb7306a3a770d17e6713871b" title="Get pointer to bytes out of the input buffer.">UsefulInputBuf_GetBytes()</a> can stand in for this because they return <code>NULL</code> if the error state has been entered. (The others can't stand in because they don't return a clearly distinct error value.) </p>

</div>
</div>
<a id="a697e730ea4c27c94ba3509bc3150c3fe" name="a697e730ea4c27c94ba3509bc3150c3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697e730ea4c27c94ba3509bc3150c3fe">&#9670;&#160;</a></span>UsefulInputBuf_GetFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float UsefulInputBuf_GetFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a float out of the input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The float.</dd></dl>
<p>See <a class="el" href="#a12633b78dd38ffe126cb8ac79ee6efd4" title="Get a byte out of the input buffer.">UsefulInputBuf_GetByte()</a>. This works the same, except it returns a float and four bytes are consumed.</p>
<p>The input bytes are interpreted in network order (big endian). </p>

</div>
</div>
<a id="a5dcb65971177f65b7bab9fd4ac499de6" name="a5dcb65971177f65b7bab9fd4ac499de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcb65971177f65b7bab9fd4ac499de6">&#9670;&#160;</a></span>UsefulInputBuf_GetUint16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t UsefulInputBuf_GetUint16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <code>uint16_t</code> out of the input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>uint16_t</code>.</dd></dl>
<p>See <a class="el" href="#a12633b78dd38ffe126cb8ac79ee6efd4" title="Get a byte out of the input buffer.">UsefulInputBuf_GetByte()</a>. This works the same, except it returns a <code>uint16_t</code> and two bytes are consumed.</p>
<p>The input bytes are interpreted in network order (big endian). </p>

</div>
</div>
<a id="a3276c0880ac251c18c5f5e9fcbe54169" name="a3276c0880ac251c18c5f5e9fcbe54169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3276c0880ac251c18c5f5e9fcbe54169">&#9670;&#160;</a></span>UsefulInputBuf_GetUint32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t UsefulInputBuf_GetUint32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <code>uint32_t</code> out of the input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>uint32_t</code>.</dd></dl>
<p>See <a class="el" href="#a12633b78dd38ffe126cb8ac79ee6efd4" title="Get a byte out of the input buffer.">UsefulInputBuf_GetByte()</a>. This works the same, except it returns a <code>uint32_t</code> and four bytes are consumed.</p>
<p>The input bytes are interpreted in network order (big endian). </p>

</div>
</div>
<a id="a5d1711958025316d9eaabade5e622d6c" name="a5d1711958025316d9eaabade5e622d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1711958025316d9eaabade5e622d6c">&#9670;&#160;</a></span>UsefulInputBuf_GetUint64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t UsefulInputBuf_GetUint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <code>uint64_t</code> out of the input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The uint64_t.</dd></dl>
<p>See <a class="el" href="#a12633b78dd38ffe126cb8ac79ee6efd4" title="Get a byte out of the input buffer.">UsefulInputBuf_GetByte()</a>. This works the same, except it returns a <code>uint64_t</code> and eight bytes are consumed.</p>
<p>The input bytes are interpreted in network order (big endian). </p>

</div>
</div>
<a id="a04bd6336074bfca7ee9919d1b0cfdd7c" name="a04bd6336074bfca7ee9919d1b0cfdd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bd6336074bfca7ee9919d1b0cfdd7c">&#9670;&#160;</a></span>UsefulInputBuf_GetUsefulBuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulInputBuf_GetUsefulBuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uNum</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> out of the input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uNum</td><td>Number of bytes to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> with ptr and length of bytes consumed.</dd></dl>
<p>This consumes <code>uNum</code> bytes from the input buffer and returns the pointer and length for them as a <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>. The length returned will always be <code>uNum</code>. The position cursor is advanced by <code>uNum</code> bytes.</p>
<p>If there are not <code>uNum</code> bytes in the input buffer, <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> will be returned and the error state is entered. </p>

</div>
</div>
<a id="a52d00cc7d9fc4fe1427cc43aeb3bfc35" name="a52d00cc7d9fc4fe1427cc43aeb3bfc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d00cc7d9fc4fe1427cc43aeb3bfc35">&#9670;&#160;</a></span>UsefulInputBuf_Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulInputBuf_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>UB</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> structure before use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>The data to parse. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a315db2634f1ebb0963255aa66f98f2" name="a8a315db2634f1ebb0963255aa66f98f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a315db2634f1ebb0963255aa66f98f2">&#9670;&#160;</a></span>UsefulInputBuf_OffsetToPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const void * UsefulInputBuf_OffsetToPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uOffset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an offset to a pointer with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uOffset</td><td>Offset in <code>pUInBuf</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>NULL</code> if <code>uOffset</code> is out of range, a pointer into the buffer if not. </dd></dl>

</div>
</div>
<a id="a878e2ac99785be22c34ea94c606a44b2" name="a878e2ac99785be22c34ea94c606a44b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878e2ac99785be22c34ea94c606a44b2">&#9670;&#160;</a></span>UsefulInputBuf_PointerToOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t UsefulInputBuf_PointerToOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a pointer to an offset with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to convert to offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SIZE_MAX if <code>p</code> is out of range, the byte offset if not. </dd></dl>

</div>
</div>
<a id="a72435670de1194deb39c5cf80b518d2a" name="a72435670de1194deb39c5cf80b518d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72435670de1194deb39c5cf80b518d2a">&#9670;&#160;</a></span>UsefulInputBuf_RetrieveUndecodedInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulInputBuf_RetrieveUndecodedInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the undecoded input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input that was given to <a class="el" href="#a52d00cc7d9fc4fe1427cc43aeb3bfc35" title="Initialize the UsefulInputBuf structure before use.">UsefulInputBuf_Init()</a>.</dd></dl>
<p>A simple convenience method, should it be useful to get the original input back. </p>

</div>
</div>
<a id="a3c61194f333fbb8914370b93af907e31" name="a3c61194f333fbb8914370b93af907e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c61194f333fbb8914370b93af907e31">&#9670;&#160;</a></span>UsefulInputBuf_Seek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulInputBuf_Seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uPos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current position in input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uPos</td><td>Position to set to.</td></tr>
  </table>
  </dd>
</dl>
<p>If the position is off the end of the input buffer, the error state is entered.</p>
<p>Seeking to a valid position in the buffer will not reset the error state. Only re-initialization will do that. </p>

</div>
</div>
<a id="a3074cca73dd828d5d60c7091e5ec7297" name="a3074cca73dd828d5d60c7091e5ec7297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3074cca73dd828d5d60c7091e5ec7297">&#9670;&#160;</a></span>UsefulInputBuf_SetBufferLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulInputBuf_SetBufferLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uNewLen</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alters the input buffer length (use with caution). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uNewLen</td><td>The new length of the input buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This alters the internal remembered length of the input buffer set when <a class="el" href="#a52d00cc7d9fc4fe1427cc43aeb3bfc35" title="Initialize the UsefulInputBuf structure before use.">UsefulInputBuf_Init()</a> was called.</p>
<p>The new length given here should always be equal to or less than the length given when <a class="el" href="#a52d00cc7d9fc4fe1427cc43aeb3bfc35" title="Initialize the UsefulInputBuf structure before use.">UsefulInputBuf_Init()</a> was called. Making it larger allows <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> to run off the input buffer.</p>
<p>The typical use is to set a length shorter than that when initialized to constrain parsing. If <a class="el" href="#af4d8437a4bdf451043c52e15b8a06d51" title="Gets the input buffer length.">UsefulInputBuf_GetBufferLength()</a> was called before this, then the original length can be restored with another call to this.</p>
<p>This should be used with caution. It is the only <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> method that can violate the safety of input buffer parsing. </p>

</div>
</div>
<a id="a74100a089e88487f1fbfc66a4eb6b615" name="a74100a089e88487f1fbfc66a4eb6b615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74100a089e88487f1fbfc66a4eb6b615">&#9670;&#160;</a></span>UsefulInputBuf_Tell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t UsefulInputBuf_Tell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUInBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns current position in input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUInBuf</td><td>Pointer to the <a class="el" href="#a40147dc1c6e6ab03d7690b195b21603f">UsefulInputBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer position of the cursor.</dd></dl>
<p>The position that the next bytes will be returned from. </p>

</div>
</div>
<a id="a5ec6768d1886aacabb09650ecd176316" name="a5ec6768d1886aacabb09650ecd176316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec6768d1886aacabb09650ecd176316">&#9670;&#160;</a></span>UsefulOutBuf_Advance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UsefulOutBuf_Advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uAmount</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the amount output assuming it was written by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uAmount</td><td>The amount to advance.</td></tr>
  </table>
  </dd>
</dl>
<p>This advances the position in the output buffer by <code>uAmount</code>. This assumes that the caller has written <code>uAmount</code> to the pointer obtained with <a class="el" href="#a9187cdecc1b636f2c4b6898db781dd7b" title="Returns pointer and length of the output buffer not yet used.">UsefulOutBuf_GetOutPlace()</a>.</p>
<p>Warning: this bypasses the buffer safety provided by <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>! </p>

</div>
</div>
<a id="abae2711f8017f87f92b31327beb2e026" name="abae2711f8017f87f92b31327beb2e026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae2711f8017f87f92b31327beb2e026">&#9670;&#160;</a></span>UsefulOutBuf_AppendByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_AppendByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>byte</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a byte to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byte</td><td>Bytes to append.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a0755837a7524edfc48ea93ce7abd0349" title="Insert a byte into the UsefulOutBuf.">UsefulOutBuf_InsertByte()</a> for details. This does the same with the insertion point at the end of the valid data. </p>

</div>
</div>
<a id="a6d7de54cb1ffbd885b6166d485fdaa6e" name="a6d7de54cb1ffbd885b6166d485fdaa6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7de54cb1ffbd885b6166d485fdaa6e">&#9670;&#160;</a></span>UsefulOutBuf_AppendData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_AppendData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>pBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uLen</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append bytes to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBytes</td><td>Pointer to bytes to append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uLen</td><td>Length of <code>pBytes</code> to append.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a2686ae4114c2e5774bb8eb613f72f480" title="Insert a data buffer into the UsefulOutBuf.">UsefulOutBuf_InsertData()</a> for details. This does the same with the insertion point at the end of the valid data. </p>

</div>
</div>
<a id="a568daf99d886e2c874918d7550336674" name="a568daf99d886e2c874918d7550336674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568daf99d886e2c874918d7550336674">&#9670;&#160;</a></span>UsefulOutBuf_AppendDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_AppendDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a <code>double</code> to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td><code>double</code> to append.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a90d0d70e0e85b9daee24ebf93944e44b" title="Insert a double into the UsefulOutBuf.">UsefulOutBuf_InsertDouble()</a> for details. This does the same with the insertion point at the end of the valid data.</p>
<p>The double will be appended in network byte order (big endian). </p>

</div>
</div>
<a id="a85e383cad22b2a869e55fa1320c655ad" name="a85e383cad22b2a869e55fa1320c655ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e383cad22b2a869e55fa1320c655ad">&#9670;&#160;</a></span>UsefulOutBuf_AppendFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_AppendFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a <code>float</code> to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td><code>float</code> to append.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a14f7f3fc882951f16eb8ed0c5c8ba10f" title="Insert a float into the UsefulOutBuf.">UsefulOutBuf_InsertFloat()</a> for details. This does the same with the insertion point at the end of the valid data.</p>
<p>The float will be appended in network byte order (big endian). </p>

</div>
</div>
<a id="a768e60e66ce61bca92aa6647d7983c00" name="a768e60e66ce61bca92aa6647d7983c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768e60e66ce61bca92aa6647d7983c00">&#9670;&#160;</a></span>UsefulOutBuf_AppendString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_AppendString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szString</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a NULL-terminated string to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">szString</td><td>NULL-terminated string to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a849e4cd2189f034211ad8ed3bc41884d" name="a849e4cd2189f034211ad8ed3bc41884d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849e4cd2189f034211ad8ed3bc41884d">&#9670;&#160;</a></span>UsefulOutBuf_AppendUint16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_AppendUint16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>uInteger16</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an integer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uInteger16</td><td>Integer to append.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a808dcfbb6f16830bc958554ad5449848" title="Insert a 16-bit integer into the UsefulOutBuf.">UsefulOutBuf_InsertUint16()</a> for details. This does the same with the insertion point at the end of the valid data.</p>
<p>The integer will be appended in network byte order (big endian). </p>

</div>
</div>
<a id="a6ac934b99c15fc41c92d3197a2af6b19" name="a6ac934b99c15fc41c92d3197a2af6b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac934b99c15fc41c92d3197a2af6b19">&#9670;&#160;</a></span>UsefulOutBuf_AppendUint32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_AppendUint32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>uInteger32</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an integer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uInteger32</td><td>Integer to append.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a4b021d38c832add340d82e474a1d14ff" title="Insert a 32-bit integer into the UsefulOutBuf.">UsefulOutBuf_InsertUint32()</a> for details. This does the same with the insertion point at the end of the valid data.</p>
<p>The integer will be appended in network byte order (big endian). </p>

</div>
</div>
<a id="a9458ac79088de56c744b6ae6e1348854" name="a9458ac79088de56c744b6ae6e1348854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9458ac79088de56c744b6ae6e1348854">&#9670;&#160;</a></span>UsefulOutBuf_AppendUint64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_AppendUint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>uInteger64</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an integer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uInteger64</td><td>Integer to append.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#ae85576eaefd482c7e6ee9483914f63af" title="Insert a 64-bit integer into the UsefulOutBuf.">UsefulOutBuf_InsertUint64()</a> for details. This does the same with the insertion point at the end of the valid data.</p>
<p>The integer will be appended in network byte order (big endian). </p>

</div>
</div>
<a id="a19a089d10c8426c57649db193c493881" name="a19a089d10c8426c57649db193c493881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a089d10c8426c57649db193c493881">&#9670;&#160;</a></span>UsefulOutBuf_AppendUsefulBuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_AppendUsefulBuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>NewData</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NewData</td><td>The <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> with the bytes to append.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a09ea2a68453e34fea416d52017b4b37c" title="Inserts bytes into the UsefulOutBuf.">UsefulOutBuf_InsertUsefulBuf()</a> for details. This does the same with the insertion point at the end of the valid data. </p>

</div>
</div>
<a id="aec55d5cccfd2e52bd482d3914d431c6c" name="aec55d5cccfd2e52bd482d3914d431c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec55d5cccfd2e52bd482d3914d431c6c">&#9670;&#160;</a></span>UsefulOutBuf_AtStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int UsefulOutBuf_AtStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether any data has been added to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if output position is at start, 0 if not. </dd></dl>

</div>
</div>
<a id="ab2485bb0b5363c9a98af71f34d8d443d" name="ab2485bb0b5363c9a98af71f34d8d443d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2485bb0b5363c9a98af71f34d8d443d">&#9670;&#160;</a></span>UsefulOutBuf_Compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UsefulOutBuf_Compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uStart1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uLen1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uStart2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uLen2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare bytes at offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uStart1</td><td>Offset of first bytes to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uLen1</td><td>Length of first bytes to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uStart2</td><td>Offset of second bytes to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uLen2</td><td>Length of second bytes to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for equality, positive if uStart1 is lexographically larger, negative if uStart2 is lexographically larger.</dd></dl>
<p>This looks into bytes that have been output at the offsets <code>start1</code> and <code>start2</code>. It compares bytes at those two starting points until they are not equal or <code>uLen1</code> or <code>uLen2</code> is reached. If the length of the string given is off the end of the output data, the string will be effectively truncated to the data in the output buffer for the comparison.</p>
<p>This returns positive when <code>uStart1</code> lexographically sorts ahead of <code>uStart2</code> and vice versa. Zero is returned if the strings compare equally.</p>
<p>If lengths are unequal and the first bytes are an exact subset of the second string, then a positve value will be returned and vice versa.</p>
<p>If either start is past the end of data in the output buffer, 0 will be returned. It is the caller's responsibility to make sure the offsets are not off the end so that a comparison is actually being made. No data will ever be read off the end of the buffer so this safe no matter what offsets are passed.</p>
<p>This is a relatively odd function in that it works on data in the output buffer. It is employed by QCBOR to sort CBOR-encoded maps that are in the output buffer. </p>

</div>
</div>
<a id="a282b65088cb6f2f39c01edfbd06ca5a1" name="a282b65088cb6f2f39c01edfbd06ca5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282b65088cb6f2f39c01edfbd06ca5a1">&#9670;&#160;</a></span>UsefulOutBuf_CopyOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulOutBuf_CopyOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>Dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy out the data put into a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Dest</td><td>The destination buffer to copy into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer and length of copied data or <code>NULLUsefulBufC</code> if it will not fit in the <code>Dest</code> buffer or the error state was entered.</dd></dl>
<p>This is the same as <a class="el" href="#a08eb02690d07e40dfdda3286bc332dbf" title="Returns the data put into a UsefulOutBuf.">UsefulOutBuf_OutUBuf()</a> except it copies the data to <code>Dest</code> rather than returning a pointer. </p>

</div>
</div>
<a id="a18f2204c0b8879f583affacbe45c907d" name="a18f2204c0b8879f583affacbe45c907d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f2204c0b8879f583affacbe45c907d">&#9670;&#160;</a></span>UsefulOutBuf_GetEndPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t UsefulOutBuf_GetEndPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns position of end of data in the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of end of data.</dd></dl>
<p>On a freshly initialized <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> with no data added, this will return 0. After 10 bytes have been added, it will return 10 and so on.</p>
<p>Generally, there is no need to call this for most uses of <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>

</div>
</div>
<a id="aeb574af9a0ea67d95d3bdf2e6821dfe6" name="aeb574af9a0ea67d95d3bdf2e6821dfe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb574af9a0ea67d95d3bdf2e6821dfe6">&#9670;&#160;</a></span>UsefulOutBuf_GetError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int UsefulOutBuf_GetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current error status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if all OK, 1 on error.</dd></dl>
<p>This returns the error status since a call to either <a class="el" href="#ab3ad9eb0d31c4d17d92cff3cc31187a9" title="Reset a UsefulOutBuf for re use.">UsefulOutBuf_Reset()</a> of <a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31" title="Initialize and supply the output buffer.">UsefulOutBuf_Init()</a>. Once a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> goes into the error state, it will stay until one of those functions is called.</p>
<p>Possible error conditions are:</p><ul>
<li>bytes to be inserted will not fit</li>
<li>insertion point is out of buffer or past valid data</li>
<li>current position is off end of buffer (probably corrupted or uninitialized)</li>
<li>detect corruption / uninitialized by bad magic number </li>
</ul>

</div>
</div>
<a id="a9187cdecc1b636f2c4b6898db781dd7b" name="a9187cdecc1b636f2c4b6898db781dd7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9187cdecc1b636f2c4b6898db781dd7b">&#9670;&#160;</a></span>UsefulOutBuf_GetOutPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> UsefulOutBuf_GetOutPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer and length of the output buffer not yet used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer and length of output buffer not used.</dd></dl>
<p>This is an escape that allows the caller to write directly to the output buffer without any checks. This doesn't change the output buffer or state. It just returns a pointer and length of the bytes remaining.</p>
<p>This is useful to avoid having the bytes to be added all in a contiguous buffer. Its use can save memory. A good example is in the COSE encrypt implementation where the output of the symmetric cipher can go directly into the output buffer, rather than having to go into an intermediate buffer.</p>
<p>See <a class="el" href="#a5ec6768d1886aacabb09650ecd176316" title="Advance the amount output assuming it was written by the caller.">UsefulOutBuf_Advance()</a> which is used to tell UsefulOutBuf how much was written.</p>
<p>Warning: this bypasses the buffer safety provided by <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>! </p>

</div>
</div>
<a id="a913b2d897a56ee1ea3c0fd981160af31" name="a913b2d897a56ee1ea3c0fd981160af31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913b2d897a56ee1ea3c0fd981160af31">&#9670;&#160;</a></span>UsefulOutBuf_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UsefulOutBuf_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>Storage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize and supply the output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pUOutBuf</td><td>The <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Storage</td><td>Buffer to output into.</td></tr>
  </table>
  </dd>
</dl>
<p>This initializes the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> with storage, sets the current position to the beginning of the buffer and clears the error state.</p>
<p>See <a class="el" href="#a7b4919809b569fd7fc5ead3fa926c9de">SizeCalculateUsefulBuf</a> for instructions on how to initialize a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> to calculate the size that would be output without actually outputting.</p>
<p>This must be called before the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> is used. </p>

</div>
</div>
<a id="a0755837a7524edfc48ea93ce7abd0349" name="a0755837a7524edfc48ea93ce7abd0349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0755837a7524edfc48ea93ce7abd0349">&#9670;&#160;</a></span>UsefulOutBuf_InsertByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_InsertByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>byte</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uPos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a byte into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byte</td><td>Bytes to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uPos</td><td>Index in output buffer at which to insert.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a09ea2a68453e34fea416d52017b4b37c" title="Inserts bytes into the UsefulOutBuf.">UsefulOutBuf_InsertUsefulBuf()</a> for details. This is the same with the difference being a single byte is to be inserted. </p>

</div>
</div>
<a id="a2686ae4114c2e5774bb8eb613f72f480" name="a2686ae4114c2e5774bb8eb613f72f480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2686ae4114c2e5774bb8eb613f72f480">&#9670;&#160;</a></span>UsefulOutBuf_InsertData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_InsertData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>pBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uLen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uPos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a data buffer into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBytes</td><td>Pointer to the bytes to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uLen</td><td>Length of the bytes to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uPos</td><td>Index in output buffer at which to insert</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a09ea2a68453e34fea416d52017b4b37c" title="Inserts bytes into the UsefulOutBuf.">UsefulOutBuf_InsertUsefulBuf()</a> for details. This is the same with the difference being a pointer and length is passed in rather than an <a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>. </p>

</div>
</div>
<a id="a90d0d70e0e85b9daee24ebf93944e44b" name="a90d0d70e0e85b9daee24ebf93944e44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d0d70e0e85b9daee24ebf93944e44b">&#9670;&#160;</a></span>UsefulOutBuf_InsertDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_InsertDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uPos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a <code>double</code> into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td><code>double</code> to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uPos</td><td>Index in output buffer at which to insert.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a09ea2a68453e34fea416d52017b4b37c" title="Inserts bytes into the UsefulOutBuf.">UsefulOutBuf_InsertUsefulBuf()</a> for details. This is the same with the difference being a <code>double</code> is to be inserted.</p>
<p>The <code>double</code> will be inserted in network byte order (big endian). </p>

</div>
</div>
<a id="a14f7f3fc882951f16eb8ed0c5c8ba10f" name="a14f7f3fc882951f16eb8ed0c5c8ba10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f7f3fc882951f16eb8ed0c5c8ba10f">&#9670;&#160;</a></span>UsefulOutBuf_InsertFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_InsertFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uPos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a <code>float</code> into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td><code>float</code> to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uPos</td><td>Index in output buffer at which to insert.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a09ea2a68453e34fea416d52017b4b37c" title="Inserts bytes into the UsefulOutBuf.">UsefulOutBuf_InsertUsefulBuf()</a> for details. This is the same with the difference being a <code>float</code> is to be inserted.</p>
<p>The <code>float</code> will be inserted in network byte order (big endian). </p>

</div>
</div>
<a id="a14baa7dec0d821f7069a74de20d86ce4" name="a14baa7dec0d821f7069a74de20d86ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14baa7dec0d821f7069a74de20d86ce4">&#9670;&#160;</a></span>UsefulOutBuf_InsertString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_InsertString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>szString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uPos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a NULL-terminated string into the UsefulOutBuf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">szString</td><td>NULL-terminated string to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uPos</td><td>Index in output buffer at which to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a808dcfbb6f16830bc958554ad5449848" name="a808dcfbb6f16830bc958554ad5449848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808dcfbb6f16830bc958554ad5449848">&#9670;&#160;</a></span>UsefulOutBuf_InsertUint16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_InsertUint16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>uInteger16</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uPos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a 16-bit integer into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uInteger16</td><td>Integer to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uPos</td><td>Index in output buffer at which to insert.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a09ea2a68453e34fea416d52017b4b37c" title="Inserts bytes into the UsefulOutBuf.">UsefulOutBuf_InsertUsefulBuf()</a> for details. This is the same with the difference being a two-byte integer is to be inserted.</p>
<p>The integer will be inserted in network byte order (big endian). </p>

</div>
</div>
<a id="a4b021d38c832add340d82e474a1d14ff" name="a4b021d38c832add340d82e474a1d14ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b021d38c832add340d82e474a1d14ff">&#9670;&#160;</a></span>UsefulOutBuf_InsertUint32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_InsertUint32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>uInteger32</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uPos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a 32-bit integer into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uInteger32</td><td>Integer to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uPos</td><td>Index in output buffer at which to insert.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a09ea2a68453e34fea416d52017b4b37c" title="Inserts bytes into the UsefulOutBuf.">UsefulOutBuf_InsertUsefulBuf()</a> for details. This is the same with the difference being a four-byte integer is to be inserted.</p>
<p>The integer will be inserted in network byte order (big endian). </p>

</div>
</div>
<a id="ae85576eaefd482c7e6ee9483914f63af" name="ae85576eaefd482c7e6ee9483914f63af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85576eaefd482c7e6ee9483914f63af">&#9670;&#160;</a></span>UsefulOutBuf_InsertUint64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_InsertUint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>uInteger64</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uPos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a 64-bit integer into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uInteger64</td><td>Integer to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uPos</td><td>Index in output buffer at which to insert.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a09ea2a68453e34fea416d52017b4b37c" title="Inserts bytes into the UsefulOutBuf.">UsefulOutBuf_InsertUsefulBuf()</a> for details. This is the same with the difference being an eight-byte integer is to be inserted.</p>
<p>The integer will be inserted in network byte order (big endian). </p>

</div>
</div>
<a id="a09ea2a68453e34fea416d52017b4b37c" name="a09ea2a68453e34fea416d52017b4b37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ea2a68453e34fea416d52017b4b37c">&#9670;&#160;</a></span>UsefulOutBuf_InsertUsefulBuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UsefulOutBuf_InsertUsefulBuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>NewData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uPos</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts bytes into the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NewData</td><td>The bytes to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uPos</td><td>Index in output buffer at which to insert.</td></tr>
  </table>
  </dd>
</dl>
<p><code>NewData</code> is the pointer and length for the bytes to be added to the output buffer. There must be room in the output buffer for all of <code>NewData</code> or an error will occur.</p>
<p>The insertion point must be between 0 and the current valid data. If not, an error will occur. Appending data to the output buffer is achieved by inserting at the end of the valid data. This can be retrieved by calling <a class="el" href="#a18f2204c0b8879f583affacbe45c907d" title="Returns position of end of data in the UsefulOutBuf.">UsefulOutBuf_GetEndPosition()</a>.</p>
<p>When insertion is performed, the bytes between the insertion point and the end of data previously added to the output buffer are slid to the right to make room for the new data.</p>
<p>Overlapping buffers are OK. <code>NewData</code> can point to data in the output buffer.</p>
<p>NewData.len may be 0 in which case nothing will be inserted.</p>
<p>If an error occurs, an error state is set in the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. No error is returned. All subsequent attempts to add data will do nothing.</p>
<p>The intended use is that all additions are made without checking for an error. The error will be taken into account when <a class="el" href="#a08eb02690d07e40dfdda3286bc332dbf" title="Returns the data put into a UsefulOutBuf.">UsefulOutBuf_OutUBuf()</a> returns <code>NullUsefulBufC</code>. <a class="el" href="#aeb574af9a0ea67d95d3bdf2e6821dfe6" title="Returns the current error status.">UsefulOutBuf_GetError()</a> can also be called to check for an error. </p>

</div>
</div>
<a id="ab52b96191e812bad2e9b53f889126d62" name="ab52b96191e812bad2e9b53f889126d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52b96191e812bad2e9b53f889126d62">&#9670;&#160;</a></span>UsefulOutBuf_IsBufferNULL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int UsefulOutBuf_IsBufferNULL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if buffer given to <a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31" title="Initialize and supply the output buffer.">UsefulOutBuf_Init()</a> was <code>NULL</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if buffer given to <a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31" title="Initialize and supply the output buffer.">UsefulOutBuf_Init()</a> was <code>NULL</code>.</dd></dl>
<p>Giving a <code>NULL</code> output buffer to <a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31" title="Initialize and supply the output buffer.">UsefulOutBuf_Init()</a> is used when just calculating the length of the encoded data. </p>

</div>
</div>
<a id="a08eb02690d07e40dfdda3286bc332dbf" name="a08eb02690d07e40dfdda3286bc332dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eb02690d07e40dfdda3286bc332dbf">&#9670;&#160;</a></span>UsefulOutBuf_OutUBuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulOutBuf_OutUBuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the data put into a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The valid data in <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> or <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> if there was an error adding data.</dd></dl>
<p>The storage for the returned data is the <code>Storage</code> parameter passed to <a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31" title="Initialize and supply the output buffer.">UsefulOutBuf_Init()</a>. See also <a class="el" href="#a282b65088cb6f2f39c01edfbd06ca5a1" title="Copy out the data put into a UsefulOutBuf.">UsefulOutBuf_CopyOut()</a>.</p>
<p>This can be called anytime and many times to get intermediate results. It doesn't change the data or reset the current position, so further data can be added. </p>

</div>
</div>
<a id="a98c955cf8da5037e148e7c9d8e28e068" name="a98c955cf8da5037e148e7c9d8e28e068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c955cf8da5037e148e7c9d8e28e068">&#9670;&#160;</a></span>UsefulOutBuf_OutUBufOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulOutBuf_OutUBufOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uOffset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns data starting at an offset that was put into a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uOffset</td><td>Offset to bytes to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULLUsefulBufC or the bytes at the offset.</dd></dl>
<p>This is the same as <a class="el" href="#a08eb02690d07e40dfdda3286bc332dbf" title="Returns the data put into a UsefulOutBuf.">UsefulOutBuf_OutUBuf()</a> except a starting offset maybe specified. It returns the bytes starting at <code>uOffset</code> to the end of what was encoded so far. Calling this with <code>uOffset</code> 0 is equivalent to <a class="el" href="#a08eb02690d07e40dfdda3286bc332dbf" title="Returns the data put into a UsefulOutBuf.">UsefulOutBuf_OutUBuf()</a>.</p>
<p>If there's nothing at <code>uOffset</code> or it is past the in the output buffer, a <a class="el" href="#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> is returned.</p>
<p>This is typically not needed in typical use. It is used by QCBOR along with <a class="el" href="#ab2485bb0b5363c9a98af71f34d8d443d" title="Compare bytes at offsets.">UsefulOutBuf_Compare()</a> and <a class="el" href="#a39613dac2316e85a665bd5000692b15c" title="Swap two regions of output bytes.">UsefulOutBuf_Swap()</a> for sorting CBOR maps. </p>

</div>
</div>
<a id="ab3ad9eb0d31c4d17d92cff3cc31187a9" name="ab3ad9eb0d31c4d17d92cff3cc31187a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ad9eb0d31c4d17d92cff3cc31187a9">&#9670;&#160;</a></span>UsefulOutBuf_Reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UsefulOutBuf_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset a <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> for re use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a></td></tr>
  </table>
  </dd>
</dl>
<p>This sets the amount of data in the output buffer to none and clears the error state.</p>
<p>The output buffer is still the same one and size as from the <a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31" title="Initialize and supply the output buffer.">UsefulOutBuf_Init()</a> call.</p>
<p>This doesn't zero the data, just resets to 0 bytes of valid data. </p>

</div>
</div>
<a id="a4d0ee8b7e2c3b9e221b166d4a786ec91" name="a4d0ee8b7e2c3b9e221b166d4a786ec91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0ee8b7e2c3b9e221b166d4a786ec91">&#9670;&#160;</a></span>UsefulOutBuf_RetrieveOutputStorage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> UsefulOutBuf_RetrieveOutputStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the storage buffer passed in to <a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31" title="Initialize and supply the output buffer.">UsefulOutBuf_Init()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>The encoding context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output storage buffer passed to <a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31" title="Initialize and supply the output buffer.">UsefulOutBuf_Init()</a>.</dd></dl>
<p>This doesn't give any information about how much has been encoded or the error state. It just returns the exact <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> given to <a class="el" href="#a913b2d897a56ee1ea3c0fd981160af31" title="Initialize and supply the output buffer.">UsefulOutBuf_Init()</a>. </p>

</div>
</div>
<a id="aa65d3e33564d8c1736abffd0e7efa5c2" name="aa65d3e33564d8c1736abffd0e7efa5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65d3e33564d8c1736abffd0e7efa5c2">&#9670;&#160;</a></span>UsefulOutBuf_RoomLeft()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t UsefulOutBuf_RoomLeft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of bytes unused used in the output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of unused bytes or zero.</dd></dl>
<p>Because of the error handling strategy and checks in <a class="el" href="#a09ea2a68453e34fea416d52017b4b37c" title="Inserts bytes into the UsefulOutBuf.">UsefulOutBuf_InsertUsefulBuf()</a> it is usually not necessary to use this. </p>

</div>
</div>
<a id="a72f7b80b24ef6a768d32129077978f98" name="a72f7b80b24ef6a768d32129077978f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f7b80b24ef6a768d32129077978f98">&#9670;&#160;</a></span>UsefulOutBuf_SubString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> UsefulOutBuf_SubString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>uStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>uLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a substring of the output data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uStart</td><td>Offset of start of substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uLen</td><td>Length of substring.</td></tr>
  </table>
  </dd>
</dl>
<p>This is the same as <a class="el" href="#a08eb02690d07e40dfdda3286bc332dbf" title="Returns the data put into a UsefulOutBuf.">UsefulOutBuf_OutUBuf()</a>, but returns a substring. <code>NULLUsefulBufC</code> is returned if the requested substring is off the end of the output bytes or if in error state. </p>

</div>
</div>
<a id="a39613dac2316e85a665bd5000692b15c" name="a39613dac2316e85a665bd5000692b15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39613dac2316e85a665bd5000692b15c">&#9670;&#160;</a></span>UsefulOutBuf_Swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UsefulOutBuf_Swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uStartOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uPivotOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uEndOffset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap two regions of output bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uStartOffset</td><td>Offset to start of bytes to be swapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uPivotOffset</td><td>Offset to pivot around which bytes are swapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEndOffset</td><td>Offset to end of region to be swappe.</td></tr>
  </table>
  </dd>
</dl>
<p>This reaches into bytes that have been output and swaps two adjacent regions.</p>
<p>If any of the offsets are outside the range of valid data, no swapping will be performed. If the start is not the smallest and the pivot is not in the middle no swapping will be performed.</p>
<p>The byte at <code>uStartOffset</code> will participate in the swapping. The byte at <code>uEndOffset</code> will not participate in the swapping, only the byte before it.</p>
<p>This is a relatively odd function in that it works on data in the output buffer. It is employed by QCBOR to bubble sort encoded CBOR maps. </p>

</div>
</div>
<a id="a098521172d27985c967cfb0b6ee07ba3" name="a098521172d27985c967cfb0b6ee07ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098521172d27985c967cfb0b6ee07ba3">&#9670;&#160;</a></span>UsefulOutBuf_WillItFit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int UsefulOutBuf_WillItFit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>pUOutBuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>uLen</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if some number of bytes will fit in the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pUOutBuf</td><td>Pointer to the <a class="el" href="#a83f01ed9a781335a27e651b4d0fe99cd">UsefulOutBuf</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uLen</td><td>Number of bytes for which to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if <code>uLen</code> bytes will fit, 0 if not.</dd></dl>
<p>Because of the error handling strategy and checks in <a class="el" href="#a09ea2a68453e34fea416d52017b4b37c" title="Inserts bytes into the UsefulOutBuf.">UsefulOutBuf_InsertUsefulBuf()</a> it is usually not necessary to use this. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
