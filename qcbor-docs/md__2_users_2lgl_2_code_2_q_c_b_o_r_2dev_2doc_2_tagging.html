<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QCBOR: Tagging</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QCBOR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Tagging</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="CBORTags"></a> </p>
<h1><a class="anchor" id="autotoc_md33"></a>
QCBOR-oriented Introduction to Tags</h1>
<h2><a class="anchor" id="autotoc_md34"></a>
New Types</h2>
<p>CBOR allows for the definition of new data types beyond basic primitives like integers, strings, array and such. These new types can either be simple extensions of a primitive type with additional semantics or more complex structures involving large aggregations.</p>
<p>The mechanism for identifying these new types is called tagging. Tagging uses a simple unsigned integer to indicate that the following CBOR item is a different type.</p>
<p>For example, when an encoded integer is preceeded by the encoded tag number 1, the integer represents an epoch date.</p>
<p>It's important to note that CBOR uses the word "tag" in an unusual way. In CBOR, a "tag" refers to the combination of the tag number and the tag content. By the normal dictionary definition, a "tag" would be just a tag number, not an aggregation of tag number and tag content By analogy, if you attach a small label to an elephant's ear, the "tag" in CBOR terms would be the combination of the label (tag number) and the elephant (tag content).</p>
<p>QCBOR always uses the term "tag number" to refer to the integer that identifies the type, "tag content" to refer to the target of the indicating integer and "tag" as the full combination of both.</p>
<p>The tag content is always a single data item. However, this item can itself be a complex structure, such as a map or an array, which may contain nested maps and arrays, allowing for arbitrarily complex tag content.</p>
<p>Tag numbers can range up to UINT64_MAX, providing a large number of possible tags. Some are defined by standards and registered in the IANA CBOR Tag Registry, while a substantial range is available for proprietary use.</p>
<p><a class="anchor" id="AreTagsOptional"></a></p>
<h2><a class="anchor" id="autotoc_md35"></a>
Are Tags "Optional"?</h2>
<p>The description of tags in <a href="https://tools.ietf.org/html/rfc7049">RFC 7049</a> and in some other places can lead one to think they are optional prefixes that can be ignored at times. This is not true.</p>
<p>As stated above, a tag is exactly a tag number and a single data item that is the tag content. Its purpose in the encoded CBOR is to indicate something is of a data type. Ignoring it would be like ignoring a typedef or struct in C.</p>
<p>However, it is common in CBOR-based protocols to use the format, semantics and definition of the tag content without it actually being a <em>tag</em>. One can think of this as <em>borrowing</em> the tag content or implied type information.</p>
<p>For example, <a href="https://tools.ietf.org/html/rfc8392">RFC 8392</a> which defines a CBOR Web Token, a CWT, says that the NumericDate field is represented as a CBOR numeric date described as tag 1 in the CBOR standard, but with the tag number 1 omitted from the encoding. A NumericDate is thus not a tag. It just borrows the content format and semantics from tag 1.</p>
<p>This borrowing of the content makes a lot of sense for data items that are labeled members of a map where the type of the data can be easily inferred by the label and the full use of a tag with a tag number would be redundant.</p>
<p>There is another way that tags are "optional". RFC 8392 serves again as an example. A CWT is officially defined as a COSE-secured map containing a bunch of claims where each claim is a labeled data item. This COSE-secured map-of-claims is the definition of a <em>CWT</em> and stands on its own as the definition of a protocol message. One can say that some protocol message is a <em>CWT</em> without ever mention the word tag or the <em>CWT Tag</em>.</p>
<p>Then RFC 8392 goes on to define a <em>CWT Tag</em> as a tag with tag number of 61 and tag content being a <em>CWT</em>. The content format definition comes first and stands on it's own.</p>
<p>To recap, the tags defined in RFC 7049 such as the date formats define the content type of the tag only in the context of the tag itself. To use the content formats outside of the tag, the content format must be borrowed. By contrast some definitions first define the content format in an independent way, then they define a tag to enclose that particular content format. A CWT is of the later sort.</p>
<p>Finally, every CBOR protocol should explicitly spell out how it is using each tag, borrowing tag content and such. If the protocol you are trying to implement doesn't, ask the designer. Generally, protocols designs should not allow for some data item to be either a tag or to be the borrowed tag content. While allowing this tag optionality is a form of Postel's law, "be liberal in what you
accept", current wisdom is somewhat the opposite.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
QCBOR Tag APIs</h2>
<p>The encode APIs are in <a class="el" href="qcbor__tag__encode_8h.html">qcbor_tag_encode.h</a> and decoding APIs in <a class="el" href="qcbor__tag__decode_8h.html">qcbor_tag_decode.h</a></p>
<p>The base primitives for encoding and decoding tag numbers are <a class="el" href="qcbor__tag__encode_8h.html#aca0fd43e2d7ee0f20da8dd7eae5d51b8" title="Add a tag number.">QCBOREncode_AddTagNumber()</a> and <a class="el" href="qcbor__tag__decode_8h.html#a73cb907a04057439b55ea0c241831699" title="Returns the tag numbers for an item.">QCBORDecode_VGetNextTagNumber()</a>. These are used in constructing and decoding tags. Note that for decoding, all tag numbers have to be consumed before decoding the tag content. This is different from QCBOR v1 where tag numbers did not have to be explicitly consumed.</p>
<p>QCBOR also provides APIs for directly encoding and decoding all the tags standardized in <a href="https://tools.ietf.org/html/rfc8949">RFC 8949</a> for dates, big numbers and such. For encoding their names start with "QCBOREncode_AddT" and for decoding they start with "QCBOREncode_GetT"</p>
<p>These APIs and structures support both the full tag form and the borrowed content form that is not a tag. An argument of type <a class="el" href="qcbor__tag__encode_8h.html#a859fc2ba4ffffb16ba54afc066053c4c">QCBOREncodeTagReq</a> and <a class="el" href="qcbor__tag__decode_8h.html#a56e70367536d37c864310dbb9777724f">QCBORDecodeTagReq</a> is provided respectively to the tag encode and decode functions to distinguish between full tags and borrowed content.</p>
<p>Early versions of QCBOR do not support encoding borrowed content. The old APIs for dates, big numbers and such are listed as deprecated, but will continue to be supported. The encode side has functions like <a class="el" href="group___deprecated_add_tag.html#ga327f4f0e11e86eaa1e2f2f60b9ea5f0e">QCBOREncode_AddDateEpoch()</a> rather than <a class="el" href="qcbor__tag__encode_8h.html#aab53d158f021438a5fc8c7c04466495c" title="Add an epoch-based date.">QCBOREncode_AddTDateEpoch()</a>. The tag decode APIs always supported borrowed content.</p>
<p>Last, <a class="el" href="qcbor__tag__decode_8h.html#a29f6df3f3fcd362e97d46537f163b2c3" title="Set the custom tag decoders.">QCBORDecode_InstallTagDecoders()</a> allows callbacks to be installed that will fire on a particular tag number. These callbacks decode the tag content and put it into a QCBORItem with a new QCBOR data type. The decoded tags show up as a <a class="el" href="qcbor__main__decode_8h.html#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> fetched by <a class="el" href="qcbor__main__decode_8h.html#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a>.</p>
<p>A set of callbacks called <a class="el" href="qcbor__tag__decode_8h.html#a03bb7669100b89c556715c5e34063efe">QCBORDecode_TagDecoderTablev1</a> is provided for all the standard tags from RFC 8949. These are not automatically installed in QCBOR v2. These were built into QCBOR v1.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Nested Tags</h2>
<p>CBOR tags are an enclosing or encapsulating format. When one tag encloses another, the enclosed tag is the content for the enclosing tag.</p>
<p>Encoding nested tags is easy with <a class="el" href="qcbor__tag__encode_8h.html#aca0fd43e2d7ee0f20da8dd7eae5d51b8" title="Add a tag number.">QCBOREncode_AddTagNumber()</a>. Just call it several times before calling the functions to encode the tag content.</p>
<p>When QCBOR decodes tags it does so by first completely processing the built-in tags that it knows how to process. It returns that processed item.</p>
<p>If tags occur that QCBOR doesn't know how to process, it will return the tag content as a <a class="el" href="qcbor__main__decode_8h.html#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> and list the tags that encapsulate. The caller then has the information it needs to process tag that QCBOR did not.</p>
<p>Nesting of tags is certainly used in CBOR protocols, but deep nesting is less common so QCBOR has an implementation limit of 4 levels of tag encapsulation on some tag content. (This can be increased by changing QCBOR_MAX_TAGS_PER_ITEM, but it will increase stack memory use by increasing the size of a QCBORItem).</p>
<p>QCBOR also saves memory by mapping the tag values larger than UINT16_MAX, so the tags have to fetched through an accessor function.</p>
<p>When decoding with <a class="el" href="qcbor__main__decode_8h.html#a5822b9efabd2a4bb1ce13390bf378b61" title="Preorder traversal like QCBORDecode_VGetNext() without use of internal error state.">QCBORDecode_GetNext()</a>, the encapsulating tags are listed in the QCBORItem returned. When decoding with spiffy decoding functions the tags encapsulating the last-decoded item are saved in the decode context and have to be fetched with <a class="el" href="qcbor__tag__decode_8h.html#a367c9fe80082532dfc25165fe590350a" title="[Deprecated] Returns the tag numbers for last-decoded item.">QCBORDecode_GetNthTagOfLast()</a>.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
Tags for Encapsulated CBOR</h2>
<p>Tag 24 and 63 deserve special mention. The content of these tags is a byte string containing encoded CBOR. The content of tag 24 is a single CBOR data item and the content of tag 63 is a CBOR sequence, more than one data item. Said another way, with tag 24 you can have deeply nested complex structures, but the if you do the one data item must be either a map or an array or a tag that defined to be complex and nested. With tag 63, the content can be a sequence of integers not held together in a map or array. Tag 63 is defined in <a href="https://tools.ietf.org/html/rfc8742">RFC 8742</a>.</p>
<p>The point of encapsulating CBOR this way is often so it can be cryptographically signed. It works well with off-the-shelf encoders and decoders to sign and verify CBOR this way because the decoder can just get the byte string that it needs to hash in a normal way, then feed the content back into another instance of the CBOR decoder.</p>
<p>It is also a way to break up complex CBOR structures so they can be decoded in layers. Usually, with CBOR one error will render the whole structure un-decodable because there is little redundancy in the encoding. By nesting like this, an error in the wrapped CBOR will not cause decoding error in the wrapping CBOR.</p>
<p>QCBOR can be asked to treat these two tags as nesting like maps and arrays are nesting with the spiffy decode <a class="el" href="qcbor__tag__decode_8h.html#a309666f4994d76b00df5d3e3dc689d76" title="Decode some byte-string wrapped CBOR.">QCBORDecode_EnterBstrWrapped()</a> decoding function. It is kind of like entering an array with one item, but with the difference that the end is defined by the end of the byte string not the end of the array.</p>
<p>These tags work like others in that they can be the proper tag or they can be the borrowed content. The QCBOR API supports this as any other tag.</p>
<p>Finally, the payload and protected headers of COSE are worth mentioning here. Neither are officially tag 24 or 63 though they look like it and QCBORs decode APIs can be used on them.</p>
<p>The protected headers are a CBOR byte string that always contains encoded CBOR. It could have been described as tag 24 borrowed content.</p>
<p>The payload is always a byte string, but only sometimes contains encoded CBOR. It never could have been defined as tag 24. When the payload is known to contain CBOR, like the case of a CWT, then QCBOR's <a class="el" href="qcbor__tag__decode_8h.html#a309666f4994d76b00df5d3e3dc689d76" title="Decode some byte-string wrapped CBOR.">QCBORDecode_EnterBstrWrapped()</a> can be used to decode it.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
Tags that Can be Ignored</h2>
<p>There are a few specially defined tags that can actually be ignored. These are the following: </p><pre class="fragment">21 Hint that content should be base64url encoded
22 Hint that content should be base64 encoded
23 Hint that content should be base16 encoded
57799 Tag that serves as a CBOR magic number
</pre><p>The content format for all these tags is that it can be any valid CBOR. Decoding of these tags doesn't have to check the content format.</p>
<p>Tag 55799 is not really for consumption by the CBOR decoder. Rather it is for file format checkers and such. The other tags are just hints in how to process the content. They don't really create new data types with new semantics.</p>
<p>Other than these four, just about every other tag defined thus far requires the content to be of a specific type and results in a new data type that a protocol decoder must understand.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
Standard Tags and the Tags Registry</h2>
<p>Tags used in CBOR protocols should at least be registered in the <a href="https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml">IANA CBOR Tags Registry</a>. A small number of tags (0-23), must be full IETF standards. Tags 24-255 require published documentation. Beyond tag 255, the tags are first come first served. Any tag can be an IETF standard if the authors chooses to take it through the process.</p>
<p>There is no range for private use, so any tag used in a CBOR protocol should be registered. The range of tag values is very large to accommodate this.</p>
<p>As described above, it is common to use data types from the registry in a CBOR protocol without the explicit tag, to borrow the content, so in a way the IANA registry is a registry of data types. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
