<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QCBOR: /Users/lgl/Code/QCBOR/dev/inc/qcbor/qcbor_main_decode.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QCBOR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bfccd401955b95cf8c75461437045ac0.html">inc</a></li><li class="navelem"><a class="el" href="dir_6c17abd51158f5ea9edde975dd55b13d.html">qcbor</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">qcbor_main_decode.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="qcbor__common_8h_source.html">qcbor/qcbor_common.h</a>&quot;</code><br />
<code>#include &quot;qcbor/qcbor_private.h&quot;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div>
<p><a href="qcbor__main__decode_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_c_b_o_r_exp_and_mantissa.html">QCBORExpAndMantissa</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___q_c_b_o_r_item.html">_QCBORItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a93295c828071d4dcf959dd125cfd5d14" id="r_a93295c828071d4dcf959dd125cfd5d14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93295c828071d4dcf959dd125cfd5d14">QCBOR_MAX_DECODE_INPUT_SIZE</a>&#160;&#160;&#160;(UINT32_MAX - 2)</td></tr>
<tr class="separator:a93295c828071d4dcf959dd125cfd5d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3096940a55e25f9cfaf3fa5a770c4da6" id="r_a3096940a55e25f9cfaf3fa5a770c4da6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3096940a55e25f9cfaf3fa5a770c4da6">QCBOR_MAX_TAGS_PER_ITEM</a>&#160;&#160;&#160;QCBOR_MAX_TAGS_PER_ITEM1</td></tr>
<tr class="separator:a3096940a55e25f9cfaf3fa5a770c4da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5917b8146669036e62a49a54b5c4c601" id="r_a5917b8146669036e62a49a54b5c4c601"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5917b8146669036e62a49a54b5c4c601">QCBOR_TYPE_NONE</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a5917b8146669036e62a49a54b5c4c601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2e0778636353cfdd1d4f13e7457eb7" id="r_a3e2e0778636353cfdd1d4f13e7457eb7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e2e0778636353cfdd1d4f13e7457eb7">QCBOR_TYPE_ANY</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a3e2e0778636353cfdd1d4f13e7457eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad060737704d85d5407ea2f342df9a66" id="r_aad060737704d85d5407ea2f342df9a66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad060737704d85d5407ea2f342df9a66">QCBOR_TYPE_INT64</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:aad060737704d85d5407ea2f342df9a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a54fa5ae26645015243d1681331405" id="r_a16a54fa5ae26645015243d1681331405"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16a54fa5ae26645015243d1681331405">QCBOR_TYPE_UINT64</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a16a54fa5ae26645015243d1681331405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d5e4cd1373d0da4e537be46fb6960f" id="r_aa4d5e4cd1373d0da4e537be46fb6960f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4d5e4cd1373d0da4e537be46fb6960f">QCBOR_TYPE_ARRAY</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:aa4d5e4cd1373d0da4e537be46fb6960f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d68008ebd9bf49e4417a21be81e429" id="r_ac2d68008ebd9bf49e4417a21be81e429"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2d68008ebd9bf49e4417a21be81e429">QCBOR_TYPE_MAP</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:ac2d68008ebd9bf49e4417a21be81e429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae886c89aec2e7cf66c01b6eddb95a96d" id="r_ae886c89aec2e7cf66c01b6eddb95a96d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae886c89aec2e7cf66c01b6eddb95a96d">QCBOR_TYPE_BYTE_STRING</a>&#160;&#160;&#160;6</td></tr>
<tr class="separator:ae886c89aec2e7cf66c01b6eddb95a96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a815aef632d06e4cf6f8d9df53edf4" id="r_a76a815aef632d06e4cf6f8d9df53edf4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76a815aef632d06e4cf6f8d9df53edf4">QCBOR_TYPE_TEXT_STRING</a>&#160;&#160;&#160;7</td></tr>
<tr class="separator:a76a815aef632d06e4cf6f8d9df53edf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa198d9c5262e614999afd356b653ba" id="r_adaa198d9c5262e614999afd356b653ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaa198d9c5262e614999afd356b653ba">QCBOR_TYPE_POSBIGNUM</a>&#160;&#160;&#160;9</td></tr>
<tr class="separator:adaa198d9c5262e614999afd356b653ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c803e8cc9062cda64c79ce227ec6ab" id="r_ae9c803e8cc9062cda64c79ce227ec6ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9c803e8cc9062cda64c79ce227ec6ab">QCBOR_TYPE_NEGBIGNUM</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:ae9c803e8cc9062cda64c79ce227ec6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ada2e6df4c177daf197808f006279c7" id="r_a3ada2e6df4c177daf197808f006279c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ada2e6df4c177daf197808f006279c7">QCBOR_TYPE_DATE_STRING</a>&#160;&#160;&#160;11</td></tr>
<tr class="separator:a3ada2e6df4c177daf197808f006279c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec90d1718b1b06f0dedab210ae53593d" id="r_aec90d1718b1b06f0dedab210ae53593d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec90d1718b1b06f0dedab210ae53593d">QCBOR_TYPE_DATE_EPOCH</a>&#160;&#160;&#160;12</td></tr>
<tr class="separator:aec90d1718b1b06f0dedab210ae53593d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028f8c16e763a72709662c9119cebcfd" id="r_a028f8c16e763a72709662c9119cebcfd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a028f8c16e763a72709662c9119cebcfd">QCBOR_TYPE_UKNOWN_SIMPLE</a>&#160;&#160;&#160;13</td></tr>
<tr class="separator:a028f8c16e763a72709662c9119cebcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b46fe9899277ba5ee3cccf72502302" id="r_a22b46fe9899277ba5ee3cccf72502302"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22b46fe9899277ba5ee3cccf72502302">QCBOR_TYPE_DECIMAL_FRACTION</a>&#160;&#160;&#160;14</td></tr>
<tr class="separator:a22b46fe9899277ba5ee3cccf72502302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad029f8f7c135baf13426e6e54ec94181" id="r_ad029f8f7c135baf13426e6e54ec94181"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad029f8f7c135baf13426e6e54ec94181">QCBOR_TYPE_DECIMAL_FRACTION_POS_BIGNUM</a>&#160;&#160;&#160;15</td></tr>
<tr class="separator:ad029f8f7c135baf13426e6e54ec94181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3257403c509df56a7882f81cbb0bc317" id="r_a3257403c509df56a7882f81cbb0bc317"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3257403c509df56a7882f81cbb0bc317">QCBOR_TYPE_DECIMAL_FRACTION_NEG_BIGNUM</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a3257403c509df56a7882f81cbb0bc317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307a3996f6f0ded4a8ece01e458e9f4c" id="r_a307a3996f6f0ded4a8ece01e458e9f4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a307a3996f6f0ded4a8ece01e458e9f4c">QCBOR_TYPE_DECIMAL_FRACTION_POS_U64</a>&#160;&#160;&#160;79</td></tr>
<tr class="separator:a307a3996f6f0ded4a8ece01e458e9f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c52fafa631ed6d2d6e40eec34492538" id="r_a0c52fafa631ed6d2d6e40eec34492538"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c52fafa631ed6d2d6e40eec34492538">QCBOR_TYPE_DECIMAL_FRACTION_NEG_U64</a>&#160;&#160;&#160;80</td></tr>
<tr class="separator:a0c52fafa631ed6d2d6e40eec34492538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e50b0121f3f861fb7b09c15aab32046" id="r_a1e50b0121f3f861fb7b09c15aab32046"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e50b0121f3f861fb7b09c15aab32046">QCBOR_TYPE_BIGFLOAT</a>&#160;&#160;&#160;17</td></tr>
<tr class="separator:a1e50b0121f3f861fb7b09c15aab32046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bd314f35849cefdbbf5eb4ea87e3b2" id="r_a54bd314f35849cefdbbf5eb4ea87e3b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54bd314f35849cefdbbf5eb4ea87e3b2">QCBOR_TYPE_BIGFLOAT_POS_BIGMANTISSA</a>&#160;&#160;&#160;18</td></tr>
<tr class="separator:a54bd314f35849cefdbbf5eb4ea87e3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c93296a67e71f45167a56dbe4b74e0" id="r_a85c93296a67e71f45167a56dbe4b74e0"><td class="memItemLeft" align="right" valign="top"><a id="a85c93296a67e71f45167a56dbe4b74e0" name="a85c93296a67e71f45167a56dbe4b74e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QCBOR_TYPE_BIGFLOAT_POS_BIGNUM</b>&#160;&#160;&#160;18</td></tr>
<tr class="separator:a85c93296a67e71f45167a56dbe4b74e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e581d94fc7b7c43c4ca9c825c32e27" id="r_af3e581d94fc7b7c43c4ca9c825c32e27"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3e581d94fc7b7c43c4ca9c825c32e27">QCBOR_TYPE_BIGFLOAT_NEG_BIGMANTISSA</a>&#160;&#160;&#160;19</td></tr>
<tr class="separator:af3e581d94fc7b7c43c4ca9c825c32e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27947e9b1a9bf2ab41a006a06d576544" id="r_a27947e9b1a9bf2ab41a006a06d576544"><td class="memItemLeft" align="right" valign="top"><a id="a27947e9b1a9bf2ab41a006a06d576544" name="a27947e9b1a9bf2ab41a006a06d576544"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QCBOR_TYPE_BIGFLOAT_NEG_BIGNUM</b>&#160;&#160;&#160;19</td></tr>
<tr class="separator:a27947e9b1a9bf2ab41a006a06d576544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7410dba8f18f169d29d90852aa7b7c2b" id="r_a7410dba8f18f169d29d90852aa7b7c2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7410dba8f18f169d29d90852aa7b7c2b">QCBOR_TYPE_BIGFLOAT_POS_U64MANTISSA</a>&#160;&#160;&#160;82</td></tr>
<tr class="separator:a7410dba8f18f169d29d90852aa7b7c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddf6f031e47e7fb6dbb264994010c56" id="r_a5ddf6f031e47e7fb6dbb264994010c56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ddf6f031e47e7fb6dbb264994010c56">QCBOR_TYPE_BIGFLOAT_NEG_U64MANTISSA</a>&#160;&#160;&#160;83</td></tr>
<tr class="separator:a5ddf6f031e47e7fb6dbb264994010c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ad705c12ce13feb36465c7667569d1" id="r_af7ad705c12ce13feb36465c7667569d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7ad705c12ce13feb36465c7667569d1">QCBOR_TYPE_FALSE</a>&#160;&#160;&#160;20</td></tr>
<tr class="separator:af7ad705c12ce13feb36465c7667569d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4625f4d10093a48fbcc274bc4823082b" id="r_a4625f4d10093a48fbcc274bc4823082b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4625f4d10093a48fbcc274bc4823082b">QCBOR_TYPE_TRUE</a>&#160;&#160;&#160;21</td></tr>
<tr class="separator:a4625f4d10093a48fbcc274bc4823082b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2f594f9dc2703e7eaff43a186953ff" id="r_a5f2f594f9dc2703e7eaff43a186953ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f2f594f9dc2703e7eaff43a186953ff">QCBOR_TYPE_NULL</a>&#160;&#160;&#160;22</td></tr>
<tr class="separator:a5f2f594f9dc2703e7eaff43a186953ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1b9d3bc96e09b9881582491bc70138" id="r_aaf1b9d3bc96e09b9881582491bc70138"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf1b9d3bc96e09b9881582491bc70138">QCBOR_TYPE_UNDEF</a>&#160;&#160;&#160;23</td></tr>
<tr class="separator:aaf1b9d3bc96e09b9881582491bc70138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6b81ebf8ffb251ac1cee59329aa9e3" id="r_a3d6b81ebf8ffb251ac1cee59329aa9e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d6b81ebf8ffb251ac1cee59329aa9e3">QCBOR_TYPE_FLOAT</a>&#160;&#160;&#160;26</td></tr>
<tr class="separator:a3d6b81ebf8ffb251ac1cee59329aa9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaeb5fec90e5121d21bfcefef094f9d0" id="r_adaeb5fec90e5121d21bfcefef094f9d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaeb5fec90e5121d21bfcefef094f9d0">QCBOR_TYPE_DOUBLE</a>&#160;&#160;&#160;27</td></tr>
<tr class="separator:adaeb5fec90e5121d21bfcefef094f9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5449717aa25cbe1a82b16e8905cfe9d9" id="r_a5449717aa25cbe1a82b16e8905cfe9d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5449717aa25cbe1a82b16e8905cfe9d9">QCBOR_TYPE_65BIT_NEG_INT</a>&#160;&#160;&#160;28</td></tr>
<tr class="separator:a5449717aa25cbe1a82b16e8905cfe9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4f7b51f2a6f29123ee31ca92f4201d" id="r_a6b4f7b51f2a6f29123ee31ca92f4201d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b4f7b51f2a6f29123ee31ca92f4201d">QCBOR_TYPE_BREAK</a>&#160;&#160;&#160;31</td></tr>
<tr class="separator:a6b4f7b51f2a6f29123ee31ca92f4201d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02b6f79a71304eda226a7ac33305479" id="r_ad02b6f79a71304eda226a7ac33305479"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad02b6f79a71304eda226a7ac33305479">QCBOR_TYPE_MAP_AS_ARRAY</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:ad02b6f79a71304eda226a7ac33305479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45be02d4e091bb1bdc7464125a7abfbb" id="r_a45be02d4e091bb1bdc7464125a7abfbb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45be02d4e091bb1bdc7464125a7abfbb">QBCOR_TYPE_WRAPPED_CBOR</a>&#160;&#160;&#160;36</td></tr>
<tr class="separator:a45be02d4e091bb1bdc7464125a7abfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8138fe9dcc929be8a30053472a727f" id="r_afd8138fe9dcc929be8a30053472a727f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd8138fe9dcc929be8a30053472a727f">QCBOR_TYPE_URI</a>&#160;&#160;&#160;44</td></tr>
<tr class="separator:afd8138fe9dcc929be8a30053472a727f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1058dfa571da376257ea954ab0d65140" id="r_a1058dfa571da376257ea954ab0d65140"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1058dfa571da376257ea954ab0d65140">QCBOR_TYPE_BASE64URL</a>&#160;&#160;&#160;45</td></tr>
<tr class="separator:a1058dfa571da376257ea954ab0d65140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7d2c62648c024c4723e48a89146e9b" id="r_a4b7d2c62648c024c4723e48a89146e9b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b7d2c62648c024c4723e48a89146e9b">QCBOR_TYPE_BASE64</a>&#160;&#160;&#160;46</td></tr>
<tr class="separator:a4b7d2c62648c024c4723e48a89146e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60ba73d5f40283b7331c433d6dcf36d" id="r_aa60ba73d5f40283b7331c433d6dcf36d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa60ba73d5f40283b7331c433d6dcf36d">QCBOR_TYPE_REGEX</a>&#160;&#160;&#160;47</td></tr>
<tr class="separator:aa60ba73d5f40283b7331c433d6dcf36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0bc098e66e9e1b086207f0674a24e9" id="r_a1a0bc098e66e9e1b086207f0674a24e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a0bc098e66e9e1b086207f0674a24e9">QCBOR_TYPE_MIME</a>&#160;&#160;&#160;48</td></tr>
<tr class="separator:a1a0bc098e66e9e1b086207f0674a24e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b3f0da822b2367dd81554f57d6ba4e" id="r_a36b3f0da822b2367dd81554f57d6ba4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36b3f0da822b2367dd81554f57d6ba4e">QCBOR_TYPE_UUID</a>&#160;&#160;&#160;49</td></tr>
<tr class="separator:a36b3f0da822b2367dd81554f57d6ba4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e838178eb3bfe0e967ebf1852c347f" id="r_a11e838178eb3bfe0e967ebf1852c347f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11e838178eb3bfe0e967ebf1852c347f">QBCOR_TYPE_WRAPPED_CBOR_SEQUENCE</a>&#160;&#160;&#160;75</td></tr>
<tr class="separator:a11e838178eb3bfe0e967ebf1852c347f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791e043313fa0f7ed01101d8f191f867" id="r_a791e043313fa0f7ed01101d8f191f867"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a791e043313fa0f7ed01101d8f191f867">QCBOR_TYPE_BINARY_MIME</a>&#160;&#160;&#160;76</td></tr>
<tr class="separator:a791e043313fa0f7ed01101d8f191f867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10039c48a7e334a04a914bddd603a013" id="r_a10039c48a7e334a04a914bddd603a013"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10039c48a7e334a04a914bddd603a013">QCBOR_TYPE_DAYS_STRING</a>&#160;&#160;&#160;77</td></tr>
<tr class="separator:a10039c48a7e334a04a914bddd603a013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42c173d948f7d1095ad107bd31f3bcd" id="r_aa42c173d948f7d1095ad107bd31f3bcd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa42c173d948f7d1095ad107bd31f3bcd">QCBOR_TYPE_DAYS_EPOCH</a>&#160;&#160;&#160;78</td></tr>
<tr class="separator:aa42c173d948f7d1095ad107bd31f3bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38d7969f22b4dcd8384a52d7c6b50a0" id="r_ae38d7969f22b4dcd8384a52d7c6b50a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae38d7969f22b4dcd8384a52d7c6b50a0">QCBOR_TYPE_TAG_NUMBER</a>&#160;&#160;&#160;127</td></tr>
<tr class="separator:ae38d7969f22b4dcd8384a52d7c6b50a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bbe3b71bfefea8935ec3dbe3abffe2" id="r_a96bbe3b71bfefea8935ec3dbe3abffe2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96bbe3b71bfefea8935ec3dbe3abffe2">QCBOR_TYPE_START_USER_DEFINED</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:a96bbe3b71bfefea8935ec3dbe3abffe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db63adc5b6af1e063e478405c767646" id="r_a6db63adc5b6af1e063e478405c767646"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6db63adc5b6af1e063e478405c767646">QCBOR_TYPE_END_USER_DEFINED</a>&#160;&#160;&#160;255</td></tr>
<tr class="separator:a6db63adc5b6af1e063e478405c767646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c90f87c0fd525ef213e320eeb03da2" id="r_ac1c90f87c0fd525ef213e320eeb03da2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1c90f87c0fd525ef213e320eeb03da2">QCBOR_LAST_UNMAPPED_TAG</a>&#160;&#160;&#160;(<a class="el" href="qcbor__common_8h.html#a1d7c44cd2993de03e65b216eb01b011f">CBOR_TAG_INVALID16</a> - QCBOR_NUM_MAPPED_TAGS - 1)</td></tr>
<tr class="separator:ac1c90f87c0fd525ef213e320eeb03da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa341e39e7cabecb74601a637912b63c" id="r_afa341e39e7cabecb74601a637912b63c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa341e39e7cabecb74601a637912b63c">QCBOR_COUNT_INDICATES_INDEFINITE_LENGTH</a>&#160;&#160;&#160;UINT16_MAX</td></tr>
<tr class="separator:afa341e39e7cabecb74601a637912b63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4377ad62925e5d38c948b6a00ac52a0" id="r_ab4377ad62925e5d38c948b6a00ac52a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4377ad62925e5d38c948b6a00ac52a0">QCBOR_DECODE_MIN_MEM_POOL_SIZE</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ab4377ad62925e5d38c948b6a00ac52a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af9cda6b7e1f5c811c87a80551f2f5647" id="r_af9cda6b7e1f5c811c87a80551f2f5647"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct___q_c_b_o_r_item.html">_QCBORItem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a></td></tr>
<tr class="separator:af9cda6b7e1f5c811c87a80551f2f5647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bb723c2756e4d4ccb20531a68bd22e" id="r_ad6bb723c2756e4d4ccb20531a68bd22e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_useful_buf_8h.html#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6bb723c2756e4d4ccb20531a68bd22e">QCBORStringAllocate</a>) (void *pAllocateCxt, void *pOldMem, size_t uNewSize)</td></tr>
<tr class="memdesc:ad6bb723c2756e4d4ccb20531a68bd22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype for the implementation of a string allocator.  <br /></td></tr>
<tr class="separator:ad6bb723c2756e4d4ccb20531a68bd22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1477d3286dd0b0f64e55886b5d2309" id="r_adb1477d3286dd0b0f64e55886b5d2309"><td class="memItemLeft" align="right" valign="top">typedef struct _QCBORDecodeContext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a></td></tr>
<tr class="separator:adb1477d3286dd0b0f64e55886b5d2309"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afb1592b19f254b747e6ad788189e8c58" id="r_afb1592b19f254b747e6ad788189e8c58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb1592b19f254b747e6ad788189e8c58">QCBORDecodeMode</a> { <br />
&#160;&#160;<a class="el" href="#afb1592b19f254b747e6ad788189e8c58a25dbb7ce42d1c8113a26c9d14a417ccf">QCBOR_DECODE_MODE_NORMAL</a> = 0
, <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a4116f650e4fa0e0279371dff415152c7">QCBOR_DECODE_MODE_MAP_STRINGS_ONLY</a> = 0x01
, <a class="el" href="#afb1592b19f254b747e6ad788189e8c58aff9fda08b08890a0d6fb6fa362d0c4e5">QCBOR_DECODE_MODE_MAP_AS_ARRAY</a> = 0x02
, <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a18cb30849d11cd00a802da8abfc0538e">QCBOR_DECODE_ALLOW_UNPROCESSED_TAG_NUMBERS</a> = 0x04
, <br />
&#160;&#160;<a class="el" href="#afb1592b19f254b747e6ad788189e8c58a0b86744331dc75040225acb376c7d8b0">QCBOR_DECODE_NO_INDEF_LENGTH</a> = 0x08
, <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a8acf951606a01693e680ce2476e7773e">QCBOR_DECODE_ONLY_PREFERRED_NUMBERS</a> = 0x10
, <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a46015d00c10d92a1cdba0f7ccf1a25ac">QCBOR_DECODE_ONLY_PREFERRED_BIG_NUMBERS</a> = 0x20
, <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a585e18a1a93a714801f096f832559e4b">QCBOR_DECODE_ONLY_SORTED_MAPS</a> = 0x40
, <br />
&#160;&#160;<a class="el" href="#afb1592b19f254b747e6ad788189e8c58ac2ab0da24b2225d3519a29a8302dc45a">QCBOR_DECODE_ONLY_REDUCED_FLOATS</a> = 0x80
, <a class="el" href="#afb1592b19f254b747e6ad788189e8c58aef84bb42f39db401df3816b1205628e2">QCBOR_DECODE_DISALLOW_DCBOR_SIMPLES</a> = 0x100
, <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a78e3849a505bc197fffb601711d1c4cc">QCBOR_DECODE_MODE_PREFERRED</a>
, <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a98b83b788b6234b0b57575da5ffe4a49">QCBOR_DECODE_MODE_CDE</a>
, <br />
&#160;&#160;<a class="el" href="#afb1592b19f254b747e6ad788189e8c58a09c12d274f55f75a76b9ace46491ea75">QCBOR_DECODE_MODE_DCBOR</a>
<br />
 }</td></tr>
<tr class="separator:afb1592b19f254b747e6ad788189e8c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afd546a1e4c3c30b2bf286495e9f963f4" id="r_afd546a1e4c3c30b2bf286495e9f963f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd546a1e4c3c30b2bf286495e9f963f4">QCBORDecode_Init</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, <a class="el" href="_useful_buf_8h.html#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> EncodedCBOR, <a class="el" href="#afb1592b19f254b747e6ad788189e8c58">QCBORDecodeMode</a> uConfigFlags)</td></tr>
<tr class="separator:afd546a1e4c3c30b2bf286495e9f963f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2d572e423cfed0a2c774b2999c53dc" id="r_aee2d572e423cfed0a2c774b2999c53dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc">QCBORDecode_SetMemPool</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, <a class="el" href="_useful_buf_8h.html#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a> MemPool, bool bAllStrings)</td></tr>
<tr class="memdesc:aee2d572e423cfed0a2c774b2999c53dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the MemPool string allocator for indefinite-length strings.  <br /></td></tr>
<tr class="separator:aee2d572e423cfed0a2c774b2999c53dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27de6d54e1c52d4ccabb5304eac04e4" id="r_aa27de6d54e1c52d4ccabb5304eac04e4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa27de6d54e1c52d4ccabb5304eac04e4">QCBORDecode_SetUpAllocator</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, <a class="el" href="#ad6bb723c2756e4d4ccb20531a68bd22e">QCBORStringAllocate</a> pfAllocateFunction, void *pAllocateContext, bool bAllStrings)</td></tr>
<tr class="memdesc:aa27de6d54e1c52d4ccabb5304eac04e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a custom string allocator for indefinite-length strings.  <br /></td></tr>
<tr class="separator:aa27de6d54e1c52d4ccabb5304eac04e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247d735e59b26e9dfab807b045d1b01b" id="r_a247d735e59b26e9dfab807b045d1b01b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a247d735e59b26e9dfab807b045d1b01b">QCBORDecode_VGetNext</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *pDecodedItem)</td></tr>
<tr class="memdesc:a247d735e59b26e9dfab807b045d1b01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.  <br /></td></tr>
<tr class="separator:a247d735e59b26e9dfab807b045d1b01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5822b9efabd2a4bb1ce13390bf378b61" id="r_a5822b9efabd2a4bb1ce13390bf378b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61">QCBORDecode_GetNext</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *pDecodedItem)</td></tr>
<tr class="memdesc:a5822b9efabd2a4bb1ce13390bf378b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preorder traversal like <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a> without use of internal error state.  <br /></td></tr>
<tr class="separator:a5822b9efabd2a4bb1ce13390bf378b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fbaea20b6c61e0bf56ac26ebce6139" id="r_a98fbaea20b6c61e0bf56ac26ebce6139"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98fbaea20b6c61e0bf56ac26ebce6139">QCBORDecode_VGetNextConsume</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *pDecodedItem)</td></tr>
<tr class="memdesc:a98fbaea20b6c61e0bf56ac26ebce6139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next item, fully consuming it if it is a map or array.  <br /></td></tr>
<tr class="separator:a98fbaea20b6c61e0bf56ac26ebce6139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72885c0d5577b9ebb389e3f12269de80" id="r_a72885c0d5577b9ebb389e3f12269de80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72885c0d5577b9ebb389e3f12269de80">QCBORDecode_VPeekNext</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *pDecodedItem)</td></tr>
<tr class="memdesc:a72885c0d5577b9ebb389e3f12269de80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next data item without consuming it.  <br /></td></tr>
<tr class="separator:a72885c0d5577b9ebb389e3f12269de80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae831dd403624d9f5d57016d3ac8004e0" id="r_ae831dd403624d9f5d57016d3ac8004e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae831dd403624d9f5d57016d3ac8004e0">QCBORDecode_PeekNext</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *pDecodedItem)</td></tr>
<tr class="memdesc:ae831dd403624d9f5d57016d3ac8004e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next data item without consuming it without use of internal error state.  <br /></td></tr>
<tr class="separator:ae831dd403624d9f5d57016d3ac8004e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef77ea67ae26675fda35b91d1dcc5cc6" id="r_aef77ea67ae26675fda35b91d1dcc5cc6"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef77ea67ae26675fda35b91d1dcc5cc6">QCBORDecode_Tell</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx)</td></tr>
<tr class="memdesc:aef77ea67ae26675fda35b91d1dcc5cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current traversal cursort offset in the input CBOR.  <br /></td></tr>
<tr class="separator:aef77ea67ae26675fda35b91d1dcc5cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56145f4f357e51e2e9f907cc40748186" id="r_a56145f4f357e51e2e9f907cc40748186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56145f4f357e51e2e9f907cc40748186">QCBORDecode_EndCheck</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx)</td></tr>
<tr class="memdesc:a56145f4f357e51e2e9f907cc40748186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether cursor is at end of the input.  <br /></td></tr>
<tr class="separator:a56145f4f357e51e2e9f907cc40748186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79109a9a307c93dddb8b582d4a3a9ceb" id="r_a79109a9a307c93dddb8b582d4a3a9ceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79109a9a307c93dddb8b582d4a3a9ceb">QCBORDecode_Finish</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx)</td></tr>
<tr class="memdesc:a79109a9a307c93dddb8b582d4a3a9ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that a decode completed successfully.  <br /></td></tr>
<tr class="separator:a79109a9a307c93dddb8b582d4a3a9ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0686470b7e1fe34f99ebd2b6b1728bfe" id="r_a0686470b7e1fe34f99ebd2b6b1728bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0686470b7e1fe34f99ebd2b6b1728bfe">QCBORDecode_PartialFinish</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, size_t *puConsumed)</td></tr>
<tr class="memdesc:a0686470b7e1fe34f99ebd2b6b1728bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes consumed so far.  <br /></td></tr>
<tr class="separator:a0686470b7e1fe34f99ebd2b6b1728bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c990fd11f2cf6791674633efce94bc7" id="r_a7c990fd11f2cf6791674633efce94bc7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_useful_buf_8h.html#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c990fd11f2cf6791674633efce94bc7">QCBORDecode_RetrieveUndecodedInput</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx)</td></tr>
<tr class="memdesc:a7c990fd11f2cf6791674633efce94bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the undecoded input buffer.  <br /></td></tr>
<tr class="separator:a7c990fd11f2cf6791674633efce94bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebef248b27efd73071bbdd345413504f" id="r_aebef248b27efd73071bbdd345413504f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebef248b27efd73071bbdd345413504f">QCBORDecode_GetError</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx)</td></tr>
<tr class="memdesc:aebef248b27efd73071bbdd345413504f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the decoding error.  <br /></td></tr>
<tr class="separator:aebef248b27efd73071bbdd345413504f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f099cf6959d73abf68e4b9cd09018d" id="r_a62f099cf6959d73abf68e4b9cd09018d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62f099cf6959d73abf68e4b9cd09018d">QCBORDecode_GetAndResetError</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx)</td></tr>
<tr class="memdesc:a62f099cf6959d73abf68e4b9cd09018d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get and reset the decoding error.  <br /></td></tr>
<tr class="separator:a62f099cf6959d73abf68e4b9cd09018d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb33f2631b4f610562a06ffe189aec58" id="r_adb33f2631b4f610562a06ffe189aec58"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb33f2631b4f610562a06ffe189aec58">QCBORDecode_IsNotWellFormedError</a> (<a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> uErr)</td></tr>
<tr class="memdesc:adb33f2631b4f610562a06ffe189aec58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an error indicates non-well-formed CBOR.  <br /></td></tr>
<tr class="separator:adb33f2631b4f610562a06ffe189aec58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660c86af310f033cf3d4a264354616f9" id="r_a660c86af310f033cf3d4a264354616f9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a660c86af310f033cf3d4a264354616f9">QCBORDecode_IsUnrecoverableError</a> (<a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> uErr)</td></tr>
<tr class="memdesc:a660c86af310f033cf3d4a264354616f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a decoding error is recoverable.  <br /></td></tr>
<tr class="separator:a660c86af310f033cf3d4a264354616f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b5979a9adfbc386fd7fc3081c8c880" id="r_a41b5979a9adfbc386fd7fc3081c8c880"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41b5979a9adfbc386fd7fc3081c8c880">QCBORDecode_SetError</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx, <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> uError)</td></tr>
<tr class="memdesc:a41b5979a9adfbc386fd7fc3081c8c880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually set error condition, or set user-defined error.  <br /></td></tr>
<tr class="separator:a41b5979a9adfbc386fd7fc3081c8c880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc65a0f8f3aed0e4d193e68753e1c9e2" id="r_afc65a0f8f3aed0e4d193e68753e1c9e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc65a0f8f3aed0e4d193e68753e1c9e2">QCBORDecode_CompatibilityV1</a> (<a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *pCtx)</td></tr>
<tr class="memdesc:afc65a0f8f3aed0e4d193e68753e1c9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">[Deprecated] Configure CBOR decoder context for QCBOR v1 compatibility.  <br /></td></tr>
<tr class="separator:afc65a0f8f3aed0e4d193e68753e1c9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="anchor" id="BasicDecode"></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
QCBOR Basic Decode</h1>
<p>This section discusses decoding assuming familiarity with the general description of this encoder-decoder in section <a class="el" href="md__2_users_2lgl_2_code_2_q_c_b_o_r_2dev_2doc_2_overview.html#Overview">Overview</a>.</p>
<p>Encoded CBOR has a tree structure where the leaf nodes are non-aggregate types like integers and strings and the intermediate nodes are either arrays or maps. Fundamentally, CBOR decoding is a pre-order traversal of this tree with CBOR sequences a minor exception. Calling <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Preorder traversal like QCBORDecode_VGetNext() without use of internal error state.">QCBORDecode_GetNext()</a> repeatedly will perform this. QCBOR maintains an internal traversal cursor. It is possible to decode any CBOR by only calling <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Preorder traversal like QCBORDecode_VGetNext() without use of internal error state.">QCBORDecode_GetNext()</a>, though this doesn't take advantage of many QCBOR features.</p>
<p><a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Preorder traversal like QCBORDecode_VGetNext() without use of internal error state.">QCBORDecode_GetNext()</a> returns a 56 byte structure called <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> that describes the decoded item including:</p><ul>
<li>The data itself, integer, string, floating-point number...</li>
<li>The label if present</li>
<li>Unprocessed tags</li>
<li>Nesting level</li>
<li>Allocation type (primarily of interest for indefinite length strings)</li>
</ul>
<p>For strings, this structure contains a pointer and length back into the original data.</p>
<p>Most of the tags that QCBOR supports directly are decoded into a representation in <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a>.</p>
<p>A string allocator must be used when decoding indefinite length strings. See <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc" title="Set up the MemPool string allocator for indefinite-length strings.">QCBORDecode_SetMemPool()</a> or <a class="el" href="#aa27de6d54e1c52d4ccabb5304eac04e4" title="Sets up a custom string allocator for indefinite-length strings.">QCBORDecode_SetUpAllocator()</a>. <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> indicates if a string was allocated with the string allocator.</p>
<p>This pre-order traversal gives natural decoding of arrays where the array members are taken in order. Maps can be decoded this way too, but the <a class="el" href="qcbor__spiffy__decode_8h.html#SpiffyDecode">SpiffyDecode</a> APIs that allow searching maps by label are often more convenient.</p>
<p><a class="anchor" id="v2-Tag-Decoding"></a> RFC 7049 called tags "optional". This was a mistake. They specify critical type information that can't be ignored by decoders.</p>
<p>QCBOR v1 always returns the tag numbers on an item in QCBORItem and leaves it up to the caller to check. Probably most callers don't know this and never added the check. There decode implementations are tolerant of random tag numbers and they shouldn't be.</p>
<p>QCBOR v2 requires tags numbers to be processed by <a class="el" href="qcbor__tag__decode_8h.html#a3414f364df8b3436a2b4886a6e249b96" title="Returns the tag numbers for an item.">QCBORDecode_GetNextTagNumber()</a>. If they are not an error will be returned.</p>
<p>This new behavior saves the caller from having to do this check (that they probably didn't know they neeeded). It is more correct behavior.</p>
<p>This behavior is not backwards compatible with v1. The v1 behavior can be restored with <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a18cb30849d11cd00a802da8abfc0538e">QCBOR_DECODE_ALLOW_UNPROCESSED_TAG_NUMBERS</a>. However, the v2 behavior is more correct, so this configuration should not be used.</p>
<p><a class="anchor" id="Decode-Errors-Overview"></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Decode Errors Overview</h1>
<p>The simplest way to handle decoding errors is to make use of the internal error tracking. The only error code check necessary is at the end when <a class="el" href="#a79109a9a307c93dddb8b582d4a3a9ceb" title="Check that a decode completed successfully.">QCBORDecode_Finish()</a> is called. To do this:</p>
<ul>
<li>Use <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a>, <a class="el" href="#a72885c0d5577b9ebb389e3f12269de80" title="Get the next data item without consuming it.">QCBORDecode_VPeekNext()</a> and any or all of the functions in <a class="el" href="qcbor__spiffy__decode_8h.html">qcbor_spiffy_decode.h</a>. Don't use <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Preorder traversal like QCBORDecode_VGetNext() without use of internal error state.">QCBORDecode_GetNext()</a> or <a class="el" href="#ae831dd403624d9f5d57016d3ac8004e0" title="Get the next data item without consuming it without use of internal error state.">QCBORDecode_PeekNext()</a>.</li>
<li>Call <a class="el" href="#a79109a9a307c93dddb8b582d4a3a9ceb" title="Check that a decode completed successfully.">QCBORDecode_Finish()</a> and check its return code.</li>
<li>Do not reference any decoded data until after <a class="el" href="#a79109a9a307c93dddb8b582d4a3a9ceb" title="Check that a decode completed successfully.">QCBORDecode_Finish()</a> returns success.</li>
</ul>
<p>Once an encoding error has been encountered, the error state is entered and further decoding function calls will do nothing. It is safe to continue calling decoding functions after an error. No error checking is necessary making the code to decode a protocol simpler. The two exceptions are <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Preorder traversal like QCBORDecode_VGetNext() without use of internal error state.">QCBORDecode_GetNext()</a> and <a class="el" href="#ae831dd403624d9f5d57016d3ac8004e0" title="Get the next data item without consuming it without use of internal error state.">QCBORDecode_PeekNext()</a> which will try to decode even if the decoder is in the error state. Use <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a> and <a class="el" href="#a72885c0d5577b9ebb389e3f12269de80" title="Get the next data item without consuming it.">QCBORDecode_VPeekNext()</a> instead.</p>
<p>While some protocols are simple enough to be decoded this way, many aren’t because the data items earlier in the protocol determine how later data items are to be decoded. In that case it is necessary to call <a class="el" href="#aebef248b27efd73071bbdd345413504f" title="Get the decoding error.">QCBORDecode_GetError()</a> to know the earlier items were successfully decoded before examining their value or type.</p>
<p>The internal decode error state can be reset by reinitializing the decoder or calling QCBORDecode_GetErrorAndReset(). Code calling QCBOR may take advantage of the internal error state to halt futher decoding and propagate errors it detects using <a class="el" href="#a41b5979a9adfbc386fd7fc3081c8c880" title="Manually set error condition, or set user-defined error.">QCBORDecode_SetError()</a>.</p>
<p>It is only useful to reset the error state by calling QCBORDecode_GetErrorAndReset() on recoverable errors. Examples of recoverable errors are a map entry not being found or integer overflow or underflow during conversion. Examples of unrecoverable errors are hitting the end of the input and array or map nesting beyond the limits of the implementation. See <a class="el" href="#a660c86af310f033cf3d4a264354616f9" title="Whether a decoding error is recoverable.">QCBORDecode_IsUnrecoverableError()</a>.Trying to reset and decode after an unrecoverable error will usually just lead to another error.</p>
<p>It is possible to use <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Preorder traversal like QCBORDecode_VGetNext() without use of internal error state.">QCBORDecode_GetNext()</a> and <a class="el" href="#ae831dd403624d9f5d57016d3ac8004e0" title="Get the next data item without consuming it without use of internal error state.">QCBORDecode_PeekNext()</a> to decode an entire protocol. However, that is usually more work, more code and less convenient than using spiffy decode functions.</p>
<p>It is also possible to mix the use of <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Preorder traversal like QCBORDecode_VGetNext() without use of internal error state.">QCBORDecode_GetNext()</a> with <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a> and the spiffy decode functions, but <a class="el" href="#aebef248b27efd73071bbdd345413504f" title="Get the decoding error.">QCBORDecode_GetError()</a> must be called and return QCBOR_SUCCESS before <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Preorder traversal like QCBORDecode_VGetNext() without use of internal error state.">QCBORDecode_GetNext()</a> is called.</p>
<p>The effect of a decoding error on the traversal cursor position varies by the decoding method called. It is unaffected by spiffy decode methods that get items by map label. <a class="el" href="qcbor__number__decode_8h.html#aef50a3274d89b7b89ae9987d0d2a98a8">QCBORDecode_GetInt64InMapN()</a> is an example of this. The traversal cursor will be advanced by most other decode methods even when there is a decode error, often leaving it in an indeterminate position. If it is necessary to continue to decoding after an error, <a class="el" href="qcbor__spiffy__decode_8h.html#a6d89d5fa2aa5db9aba2f53a64257f998" title="Reset traversal cursor to start of map, array, byte-string wrapped CBOR or start of input.">QCBORDecode_Rewind()</a> can be used to reset it to a known-good position.</p>
<p>When using spiffy decode methods to get an item by label from a map the whole map is internally traversed including nested arrays and maps. If there is any unrecoverable error during that traversal, the retrieval by label will fail. The unrecoverable error will be returned even if it is not because the item being sought is in error. Recoverable errors will be ignored unless they are on the item being sought, in which case the unrecoverable error will be returned. Unrecoverable errors are those indicated by <a class="el" href="#a660c86af310f033cf3d4a264354616f9" title="Whether a decoding error is recoverable.">QCBORDecode_IsUnrecoverableError()</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a45be02d4e091bb1bdc7464125a7abfbb" name="a45be02d4e091bb1bdc7464125a7abfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45be02d4e091bb1bdc7464125a7abfbb">&#9670;&#160;</a></span>QBCOR_TYPE_WRAPPED_CBOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QBCOR_TYPE_WRAPPED_CBOR&#160;&#160;&#160;36</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encoded CBOR that is wrapped in a byte string. Often used when the CBOR is to be hashed for signing or HMAC. See also <a class="el" href="#a11e838178eb3bfe0e967ebf1852c347f">QBCOR_TYPE_WRAPPED_CBOR_SEQUENCE</a>. Data is in <code>val.string</code>. </p>

</div>
</div>
<a id="a11e838178eb3bfe0e967ebf1852c347f" name="a11e838178eb3bfe0e967ebf1852c347f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e838178eb3bfe0e967ebf1852c347f">&#9670;&#160;</a></span>QBCOR_TYPE_WRAPPED_CBOR_SEQUENCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QBCOR_TYPE_WRAPPED_CBOR_SEQUENCE&#160;&#160;&#160;75</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A CBOR sequence per RFC 8742. See also @ ref QBCOR_TYPE_WRAPPED_CBOR. Data is in <code>val.string</code>. </p>

</div>
</div>
<a id="afa341e39e7cabecb74601a637912b63c" name="afa341e39e7cabecb74601a637912b63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa341e39e7cabecb74601a637912b63c">&#9670;&#160;</a></span>QCBOR_COUNT_INDICATES_INDEFINITE_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_COUNT_INDICATES_INDEFINITE_LENGTH&#160;&#160;&#160;UINT16_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An array or map's length is indefinite when it has this value. </p>

</div>
</div>
<a id="ab4377ad62925e5d38c948b6a00ac52a0" name="ab4377ad62925e5d38c948b6a00ac52a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4377ad62925e5d38c948b6a00ac52a0">&#9670;&#160;</a></span>QCBOR_DECODE_MIN_MEM_POOL_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_DECODE_MIN_MEM_POOL_SIZE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For the built-in string allocator available via <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc" title="Set up the MemPool string allocator for indefinite-length strings.">QCBORDecode_SetMemPool()</a>, this is the size overhead needed internally. The amount of memory available for decoded strings is the size of the buffer given to <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc" title="Set up the MemPool string allocator for indefinite-length strings.">QCBORDecode_SetMemPool()</a> less this amount.</p>
<p>This doesn't apply to custom string allocators, only to the one available via <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc" title="Set up the MemPool string allocator for indefinite-length strings.">QCBORDecode_SetMemPool()</a>. </p>

</div>
</div>
<a id="ac1c90f87c0fd525ef213e320eeb03da2" name="ac1c90f87c0fd525ef213e320eeb03da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c90f87c0fd525ef213e320eeb03da2">&#9670;&#160;</a></span>QCBOR_LAST_UNMAPPED_TAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_LAST_UNMAPPED_TAG&#160;&#160;&#160;(<a class="el" href="qcbor__common_8h.html#a1d7c44cd2993de03e65b216eb01b011f">CBOR_TAG_INVALID16</a> - QCBOR_NUM_MAPPED_TAGS - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The largest value in <code>utags</code> that is unmapped and can be used without mapping it through <a class="el" href="qcbor__tag__decode_8h.html#a3c4e6e6974c29c933dc3279c84aa1e7c" title="Returns the tag numbers for a decoded item.">QCBORDecode_GetNthTagNumber()</a>. </p>

</div>
</div>
<a id="a93295c828071d4dcf959dd125cfd5d14" name="a93295c828071d4dcf959dd125cfd5d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93295c828071d4dcf959dd125cfd5d14">&#9670;&#160;</a></span>QCBOR_MAX_DECODE_INPUT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_MAX_DECODE_INPUT_SIZE&#160;&#160;&#160;(UINT32_MAX - 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum size of input to the decoder. Slightly less than <code>UINT32_MAX</code> to make room for some special indicator values. </p>

</div>
</div>
<a id="a3096940a55e25f9cfaf3fa5a770c4da6" name="a3096940a55e25f9cfaf3fa5a770c4da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3096940a55e25f9cfaf3fa5a770c4da6">&#9670;&#160;</a></span>QCBOR_MAX_TAGS_PER_ITEM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_MAX_TAGS_PER_ITEM&#160;&#160;&#160;QCBOR_MAX_TAGS_PER_ITEM1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of tags that may occur on an individual nested item. Typically 4. </p>

</div>
</div>
<a id="a5449717aa25cbe1a82b16e8905cfe9d9" name="a5449717aa25cbe1a82b16e8905cfe9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5449717aa25cbe1a82b16e8905cfe9d9">&#9670;&#160;</a></span>QCBOR_TYPE_65BIT_NEG_INT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_65BIT_NEG_INT&#160;&#160;&#160;28</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Special type for integers between -2^63 - 1 to -2^64 that can't be returned as <a class="el" href="#aad060737704d85d5407ea2f342df9a66">QCBOR_TYPE_INT64</a> because they don't fit in an int64_t. The value is returned in <code>val.uint64</code>, but this isn't the number transmitted. Do this arithmatic (carefully to avoid over/underflow) to get the value transmitted: - val.uint64 - 1. See <a class="el" href="qcbor__number__encode_8h.html#aedb3ddf12b9ace113abf2d4158c1db22" title="Add a negative 64-bit integer to encoded output.">QCBOREncode_AddNegativeUInt64()</a> for a longer explanation and warning. </p>

</div>
</div>
<a id="a3e2e0778636353cfdd1d4f13e7457eb7" name="a3e2e0778636353cfdd1d4f13e7457eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2e0778636353cfdd1d4f13e7457eb7">&#9670;&#160;</a></span>QCBOR_TYPE_ANY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_ANY&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Never used in QCBORItem. Used by functions that match QCBOR types. </p>

</div>
</div>
<a id="aa4d5e4cd1373d0da4e537be46fb6960f" name="aa4d5e4cd1373d0da4e537be46fb6960f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d5e4cd1373d0da4e537be46fb6960f">&#9670;&#160;</a></span>QCBOR_TYPE_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_ARRAY&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for an array. See comments on <code>val.uCount</code>. </p>

</div>
</div>
<a id="a4b7d2c62648c024c4723e48a89146e9b" name="a4b7d2c62648c024c4723e48a89146e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7d2c62648c024c4723e48a89146e9b">&#9670;&#160;</a></span>QCBOR_TYPE_BASE64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_BASE64&#160;&#160;&#160;46</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Text is base64 encoded in RFC 4648. The base64 encoding is NOT removed. Data is in <code>val.string</code>. </p>

</div>
</div>
<a id="a1058dfa571da376257ea954ab0d65140" name="a1058dfa571da376257ea954ab0d65140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1058dfa571da376257ea954ab0d65140">&#9670;&#160;</a></span>QCBOR_TYPE_BASE64URL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_BASE64URL&#160;&#160;&#160;45</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Text is base64 URL encoded in RFC 4648. The base64 encoding is NOT removed. Data is in <code>val.string</code>. </p>

</div>
</div>
<a id="a1e50b0121f3f861fb7b09c15aab32046" name="a1e50b0121f3f861fb7b09c15aab32046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e50b0121f3f861fb7b09c15aab32046">&#9670;&#160;</a></span>QCBOR_TYPE_BIGFLOAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_BIGFLOAT&#160;&#160;&#160;17</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A floating-point number made of base-2 exponent and integer mantissa. See <a class="el" href="struct_q_c_b_o_r_exp_and_mantissa.html#expAndMantissa">expAndMantissa</a> and <a class="el" href="qcbor__number__encode_8h.html#a8179cbe73b571547fed5c2e2252d874b" title="Add a big floating-point number to the encoded output.">QCBOREncode_AddTBigFloat()</a>. </p>

</div>
</div>
<a id="af3e581d94fc7b7c43c4ca9c825c32e27" name="af3e581d94fc7b7c43c4ca9c825c32e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e581d94fc7b7c43c4ca9c825c32e27">&#9670;&#160;</a></span>QCBOR_TYPE_BIGFLOAT_NEG_BIGMANTISSA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_BIGFLOAT_NEG_BIGMANTISSA&#160;&#160;&#160;19</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A floating-point number made of base-2 exponent and negative big number mantissa. See <a class="el" href="struct_q_c_b_o_r_exp_and_mantissa.html#expAndMantissa">expAndMantissa</a> and <a class="el" href="qcbor__number__encode_8h.html#af4a308cd36745636ba7d1d00e544eae6" title="Add a big floating-point number with a big number mantissa.">QCBOREncode_AddTBigFloatBigMantissa()</a>. </p>

</div>
</div>
<a id="a5ddf6f031e47e7fb6dbb264994010c56" name="a5ddf6f031e47e7fb6dbb264994010c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddf6f031e47e7fb6dbb264994010c56">&#9670;&#160;</a></span>QCBOR_TYPE_BIGFLOAT_NEG_U64MANTISSA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_BIGFLOAT_NEG_U64MANTISSA&#160;&#160;&#160;83</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A floating-point number made of base-2 exponent and negative big number mantissa. See <a class="el" href="struct_q_c_b_o_r_exp_and_mantissa.html#expAndMantissa">expAndMantissa</a> and <a class="el" href="qcbor__number__encode_8h.html#af4a308cd36745636ba7d1d00e544eae6" title="Add a big floating-point number with a big number mantissa.">QCBOREncode_AddTBigFloatBigMantissa()</a>. </p>

</div>
</div>
<a id="a54bd314f35849cefdbbf5eb4ea87e3b2" name="a54bd314f35849cefdbbf5eb4ea87e3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bd314f35849cefdbbf5eb4ea87e3b2">&#9670;&#160;</a></span>QCBOR_TYPE_BIGFLOAT_POS_BIGMANTISSA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_BIGFLOAT_POS_BIGMANTISSA&#160;&#160;&#160;18</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A floating-point number made of base-2 exponent and positive big number mantissa. See <a class="el" href="struct_q_c_b_o_r_exp_and_mantissa.html#expAndMantissa">expAndMantissa</a> and <a class="el" href="qcbor__number__encode_8h.html#af4a308cd36745636ba7d1d00e544eae6" title="Add a big floating-point number with a big number mantissa.">QCBOREncode_AddTBigFloatBigMantissa()</a>. </p>

</div>
</div>
<a id="a7410dba8f18f169d29d90852aa7b7c2b" name="a7410dba8f18f169d29d90852aa7b7c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7410dba8f18f169d29d90852aa7b7c2b">&#9670;&#160;</a></span>QCBOR_TYPE_BIGFLOAT_POS_U64MANTISSA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_BIGFLOAT_POS_U64MANTISSA&#160;&#160;&#160;82</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A floating-point number made of base-2 exponent and positive big number mantissa. See <a class="el" href="struct_q_c_b_o_r_exp_and_mantissa.html#expAndMantissa">expAndMantissa</a> and <a class="el" href="qcbor__number__encode_8h.html#af4a308cd36745636ba7d1d00e544eae6" title="Add a big floating-point number with a big number mantissa.">QCBOREncode_AddTBigFloatBigMantissa()</a>. </p>

</div>
</div>
<a id="a791e043313fa0f7ed01101d8f191f867" name="a791e043313fa0f7ed01101d8f191f867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791e043313fa0f7ed01101d8f191f867">&#9670;&#160;</a></span>QCBOR_TYPE_BINARY_MIME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_BINARY_MIME&#160;&#160;&#160;76</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary MIME per RFC 2045. See also <a class="el" href="#a1a0bc098e66e9e1b086207f0674a24e9">QCBOR_TYPE_MIME</a>. Data is in <code>val.string</code>. </p>

</div>
</div>
<a id="a6b4f7b51f2a6f29123ee31ca92f4201d" name="a6b4f7b51f2a6f29123ee31ca92f4201d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4f7b51f2a6f29123ee31ca92f4201d">&#9670;&#160;</a></span>QCBOR_TYPE_BREAK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_BREAK&#160;&#160;&#160;31</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used internally; never returned <br  />
 </p>

</div>
</div>
<a id="ae886c89aec2e7cf66c01b6eddb95a96d" name="ae886c89aec2e7cf66c01b6eddb95a96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae886c89aec2e7cf66c01b6eddb95a96d">&#9670;&#160;</a></span>QCBOR_TYPE_BYTE_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_BYTE_STRING&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a buffer full of bytes. Data is in <code>val.string</code>. </p>

</div>
</div>
<a id="aec90d1718b1b06f0dedab210ae53593d" name="aec90d1718b1b06f0dedab210ae53593d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec90d1718b1b06f0dedab210ae53593d">&#9670;&#160;</a></span>QCBOR_TYPE_DATE_EPOCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_DATE_EPOCH&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for integer seconds since Jan 1970 + floating-point fraction. Data is in <code>val.epochDate</code> </p>

</div>
</div>
<a id="a3ada2e6df4c177daf197808f006279c7" name="a3ada2e6df4c177daf197808f006279c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ada2e6df4c177daf197808f006279c7">&#9670;&#160;</a></span>QCBOR_TYPE_DATE_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_DATE_STRING&#160;&#160;&#160;11</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> date string, possibly with time zone. Data is in <code>val.string</code> . Note this was previously in <code>val.dateString</code>, however this is the same as val.string being the same type in same union. val.dateString will be deprecated.. </p>

</div>
</div>
<a id="aa42c173d948f7d1095ad107bd31f3bcd" name="aa42c173d948f7d1095ad107bd31f3bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42c173d948f7d1095ad107bd31f3bcd">&#9670;&#160;</a></span>QCBOR_TYPE_DAYS_EPOCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_DAYS_EPOCH&#160;&#160;&#160;78</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for integer days since Jan 1 1970 described in <a href="https://tools.ietf.org/html/rfc8943">RFC 8943</a>. Data is in <code>val.epochDays</code> </p>

</div>
</div>
<a id="a10039c48a7e334a04a914bddd603a013" name="a10039c48a7e334a04a914bddd603a013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10039c48a7e334a04a914bddd603a013">&#9670;&#160;</a></span>QCBOR_TYPE_DAYS_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_DAYS_STRING&#160;&#160;&#160;77</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for <a href="https://tools.ietf.org/html/rfc8943">RFC 8943</a> date string, a date with no time or time zone info. Data is in <code>val.string</code> </p>

</div>
</div>
<a id="a22b46fe9899277ba5ee3cccf72502302" name="a22b46fe9899277ba5ee3cccf72502302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b46fe9899277ba5ee3cccf72502302">&#9670;&#160;</a></span>QCBOR_TYPE_DECIMAL_FRACTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_DECIMAL_FRACTION&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A decimal fraction made of decimal exponent and integer mantissa. See <a class="el" href="struct_q_c_b_o_r_exp_and_mantissa.html#expAndMantissa">expAndMantissa</a> and <a class="el" href="qcbor__number__encode_8h.html#a707fdf4f66812cf13012adbed721513d" title="Add a decimal fraction.">QCBOREncode_AddTDecimalFraction()</a>. </p>

</div>
</div>
<a id="a3257403c509df56a7882f81cbb0bc317" name="a3257403c509df56a7882f81cbb0bc317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3257403c509df56a7882f81cbb0bc317">&#9670;&#160;</a></span>QCBOR_TYPE_DECIMAL_FRACTION_NEG_BIGNUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_DECIMAL_FRACTION_NEG_BIGNUM&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A decimal fraction made of decimal exponent and negative big number mantissa. See <a class="el" href="struct_q_c_b_o_r_exp_and_mantissa.html#expAndMantissa">expAndMantissa</a> and <a class="el" href="qcbor__number__encode_8h.html#a256c53fff54ba4ce447ff4b908250539" title="Add a decimal fraction with a big number mantissa..">QCBOREncode_AddTDecimalFractionBigMantissa()</a>. </p>

</div>
</div>
<a id="a0c52fafa631ed6d2d6e40eec34492538" name="a0c52fafa631ed6d2d6e40eec34492538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c52fafa631ed6d2d6e40eec34492538">&#9670;&#160;</a></span>QCBOR_TYPE_DECIMAL_FRACTION_NEG_U64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_DECIMAL_FRACTION_NEG_U64&#160;&#160;&#160;80</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A decimal fraction made of decimal exponent and negative big number mantissa. See <a class="el" href="struct_q_c_b_o_r_exp_and_mantissa.html#expAndMantissa">expAndMantissa</a> and <a class="el" href="qcbor__number__encode_8h.html#a256c53fff54ba4ce447ff4b908250539" title="Add a decimal fraction with a big number mantissa..">QCBOREncode_AddTDecimalFractionBigMantissa()</a>. </p>

</div>
</div>
<a id="ad029f8f7c135baf13426e6e54ec94181" name="ad029f8f7c135baf13426e6e54ec94181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad029f8f7c135baf13426e6e54ec94181">&#9670;&#160;</a></span>QCBOR_TYPE_DECIMAL_FRACTION_POS_BIGNUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_DECIMAL_FRACTION_POS_BIGNUM&#160;&#160;&#160;15</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A decimal fraction made of decimal exponent and positive big number mantissa. See <a class="el" href="struct_q_c_b_o_r_exp_and_mantissa.html#expAndMantissa">expAndMantissa</a> and <a class="el" href="qcbor__number__encode_8h.html#a256c53fff54ba4ce447ff4b908250539" title="Add a decimal fraction with a big number mantissa..">QCBOREncode_AddTDecimalFractionBigMantissa()</a>. </p>

</div>
</div>
<a id="a307a3996f6f0ded4a8ece01e458e9f4c" name="a307a3996f6f0ded4a8ece01e458e9f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307a3996f6f0ded4a8ece01e458e9f4c">&#9670;&#160;</a></span>QCBOR_TYPE_DECIMAL_FRACTION_POS_U64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_DECIMAL_FRACTION_POS_U64&#160;&#160;&#160;79</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A decimal fraction made of decimal exponent and positive uint64_t . See <a class="el" href="qcbor__number__encode_8h.html#a256c53fff54ba4ce447ff4b908250539" title="Add a decimal fraction with a big number mantissa..">QCBOREncode_AddTDecimalFractionBigMantissa()</a>. </p>

</div>
</div>
<a id="adaeb5fec90e5121d21bfcefef094f9d0" name="adaeb5fec90e5121d21bfcefef094f9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaeb5fec90e5121d21bfcefef094f9d0">&#9670;&#160;</a></span>QCBOR_TYPE_DOUBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_DOUBLE&#160;&#160;&#160;27</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a double floating-point number. Data is in <code>val.dfnum</code>. </p>

</div>
</div>
<a id="a6db63adc5b6af1e063e478405c767646" name="a6db63adc5b6af1e063e478405c767646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db63adc5b6af1e063e478405c767646">&#9670;&#160;</a></span>QCBOR_TYPE_END_USER_DEFINED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_END_USER_DEFINED&#160;&#160;&#160;255</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End of user-defined data types. </p>

</div>
</div>
<a id="af7ad705c12ce13feb36465c7667569d1" name="af7ad705c12ce13feb36465c7667569d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ad705c12ce13feb36465c7667569d1">&#9670;&#160;</a></span>QCBOR_TYPE_FALSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_FALSE&#160;&#160;&#160;20</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the simple value false. </p>

</div>
</div>
<a id="a3d6b81ebf8ffb251ac1cee59329aa9e3" name="a3d6b81ebf8ffb251ac1cee59329aa9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6b81ebf8ffb251ac1cee59329aa9e3">&#9670;&#160;</a></span>QCBOR_TYPE_FLOAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_FLOAT&#160;&#160;&#160;26</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a floating-point number. Data is in <code>val.fnum</code>. </p>

</div>
</div>
<a id="aad060737704d85d5407ea2f342df9a66" name="aad060737704d85d5407ea2f342df9a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad060737704d85d5407ea2f342df9a66">&#9670;&#160;</a></span>QCBOR_TYPE_INT64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_INT64&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for an integer that decoded either between <code>INT64_MIN</code> and <code>INT32_MIN</code> or <code>INT32_MAX</code> and <code>INT64_MAX</code>. Data is in member <code>val.int64</code>. See also <a class="el" href="#a5449717aa25cbe1a82b16e8905cfe9d9">QCBOR_TYPE_65BIT_NEG_INT</a> </p>

</div>
</div>
<a id="ac2d68008ebd9bf49e4417a21be81e429" name="ac2d68008ebd9bf49e4417a21be81e429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d68008ebd9bf49e4417a21be81e429">&#9670;&#160;</a></span>QCBOR_TYPE_MAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_MAP&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a map. See comments on <code>val.uCount</code>. </p>

</div>
</div>
<a id="ad02b6f79a71304eda226a7ac33305479" name="ad02b6f79a71304eda226a7ac33305479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02b6f79a71304eda226a7ac33305479">&#9670;&#160;</a></span>QCBOR_TYPE_MAP_AS_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_MAP_AS_ARRAY&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For <a class="el" href="#afb1592b19f254b747e6ad788189e8c58aff9fda08b08890a0d6fb6fa362d0c4e5">QCBOR_DECODE_MODE_MAP_AS_ARRAY</a> decode mode, a map that is being traversed as an array. See <a class="el" href="#afd546a1e4c3c30b2bf286495e9f963f4">QCBORDecode_Init()</a> </p>

</div>
</div>
<a id="a1a0bc098e66e9e1b086207f0674a24e9" name="a1a0bc098e66e9e1b086207f0674a24e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0bc098e66e9e1b086207f0674a24e9">&#9670;&#160;</a></span>QCBOR_TYPE_MIME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_MIME&#160;&#160;&#160;48</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-binary MIME per RFC 2045. See also <a class="el" href="#a791e043313fa0f7ed01101d8f191f867">QCBOR_TYPE_BINARY_MIME</a>. Data is in <code>val.string</code>. </p>

</div>
</div>
<a id="ae9c803e8cc9062cda64c79ce227ec6ab" name="ae9c803e8cc9062cda64c79ce227ec6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c803e8cc9062cda64c79ce227ec6ab">&#9670;&#160;</a></span>QCBOR_TYPE_NEGBIGNUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_NEGBIGNUM&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a negative big number. Data is in <code>val.bignum</code>, a pointer and a length. Type 1 integers in the range of [-2^64, -2^63 - 1] are returned in this type. One must be subtracted from what is returned to get the actual value. This is because of the way CBOR negative numbers are represented. QCBOR doesn't do this because it can't be done without storage allocation and QCBOR avoids storage allocation for the most part. For example, if 1 is subtraced from a negative big number that is the two bytes 0xff 0xff, the result would be 0x01 0x00 0x00, one byte longer than what was received. See <a class="el" href="qcbor__tag__decode_8h.html#a8068561f5838cd8038010eb229fbd7ed" title="Process standard CBOR tags whose content is a string.">QCBORDecode_StringsTagCB()</a>. and <a class="el" href="qcbor__common_8h.html#acf35c30486c5c22bc76934951d106a19">CBOR_TAG_NEG_BIGNUM</a>. </p>

</div>
</div>
<a id="a5917b8146669036e62a49a54b5c4c601" name="a5917b8146669036e62a49a54b5c4c601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5917b8146669036e62a49a54b5c4c601">&#9670;&#160;</a></span>QCBOR_TYPE_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_NONE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The data type is unknown, unset or invalid. </p>

</div>
</div>
<a id="a5f2f594f9dc2703e7eaff43a186953ff" name="a5f2f594f9dc2703e7eaff43a186953ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2f594f9dc2703e7eaff43a186953ff">&#9670;&#160;</a></span>QCBOR_TYPE_NULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_NULL&#160;&#160;&#160;22</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the simple value null. </p>

</div>
</div>
<a id="adaa198d9c5262e614999afd356b653ba" name="adaa198d9c5262e614999afd356b653ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa198d9c5262e614999afd356b653ba">&#9670;&#160;</a></span>QCBOR_TYPE_POSBIGNUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_POSBIGNUM&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a positive big number. Data is in <code>val.bignum</code>, a pointer and a length. See <a class="el" href="qcbor__tag__decode_8h.html#a8068561f5838cd8038010eb229fbd7ed" title="Process standard CBOR tags whose content is a string.">QCBORDecode_StringsTagCB()</a> and <a class="el" href="qcbor__common_8h.html#a47367e57493f51fbf0253df494a17743">CBOR_TAG_POS_BIGNUM</a>. </p>

</div>
</div>
<a id="aa60ba73d5f40283b7331c433d6dcf36d" name="aa60ba73d5f40283b7331c433d6dcf36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60ba73d5f40283b7331c433d6dcf36d">&#9670;&#160;</a></span>QCBOR_TYPE_REGEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_REGEX&#160;&#160;&#160;47</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PERL-compatible regular expression. Data is in <code>val.string</code>. </p>

</div>
</div>
<a id="a96bbe3b71bfefea8935ec3dbe3abffe2" name="a96bbe3b71bfefea8935ec3dbe3abffe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bbe3b71bfefea8935ec3dbe3abffe2">&#9670;&#160;</a></span>QCBOR_TYPE_START_USER_DEFINED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_START_USER_DEFINED&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start of user-defined data types. The range is mainly for user-defined tag content decoders. See QCBORTagContentCallBack </p>

</div>
</div>
<a id="ae38d7969f22b4dcd8384a52d7c6b50a0" name="ae38d7969f22b4dcd8384a52d7c6b50a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38d7969f22b4dcd8384a52d7c6b50a0">&#9670;&#160;</a></span>QCBOR_TYPE_TAG_NUMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_TAG_NUMBER&#160;&#160;&#160;127</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used internally; never returned <br  />
 </p>

</div>
</div>
<a id="a76a815aef632d06e4cf6f8d9df53edf4" name="a76a815aef632d06e4cf6f8d9df53edf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a815aef632d06e4cf6f8d9df53edf4">&#9670;&#160;</a></span>QCBOR_TYPE_TEXT_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_TEXT_STRING&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a UTF-8 string. It is not NULL-terminated. See <a class="el" href="qcbor__main__encode_8h.html#a9f3fe0d53bc053327c18138d296ca4c2" title="Add a UTF-8 text string to the encoded output.">QCBOREncode_AddText()</a> for a discussion of line endings in CBOR. Data is in <code>val.string</code>. <br  />
 </p>

</div>
</div>
<a id="a4625f4d10093a48fbcc274bc4823082b" name="a4625f4d10093a48fbcc274bc4823082b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4625f4d10093a48fbcc274bc4823082b">&#9670;&#160;</a></span>QCBOR_TYPE_TRUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_TRUE&#160;&#160;&#160;21</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the simple value true. </p>

</div>
</div>
<a id="a16a54fa5ae26645015243d1681331405" name="a16a54fa5ae26645015243d1681331405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a54fa5ae26645015243d1681331405">&#9670;&#160;</a></span>QCBOR_TYPE_UINT64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_UINT64&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for an integer that decoded to a more than <code>INT64_MAX</code> and <code>UINT64_MAX</code>. Data is in member <code>val.uint64</code>. </p>

</div>
</div>
<a id="a028f8c16e763a72709662c9119cebcfd" name="a028f8c16e763a72709662c9119cebcfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028f8c16e763a72709662c9119cebcfd">&#9670;&#160;</a></span>QCBOR_TYPE_UKNOWN_SIMPLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_UKNOWN_SIMPLE&#160;&#160;&#160;13</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The CBOR major type "simple" has a small integer value indicating what it is. The standard CBOR simples are true, false, null, undef (values 20-23) and float-point numbers (values 25-27). The values 0-19 and 32-255 are unassigned and may be used if registered with in the IANA Simple Values Registry. If these unassigned simple values occur in the input they will be decoded as this. The value is in <code>val.uSimple</code>. </p>

</div>
</div>
<a id="aaf1b9d3bc96e09b9881582491bc70138" name="aaf1b9d3bc96e09b9881582491bc70138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1b9d3bc96e09b9881582491bc70138">&#9670;&#160;</a></span>QCBOR_TYPE_UNDEF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_UNDEF&#160;&#160;&#160;23</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the simple value undef. </p>

</div>
</div>
<a id="afd8138fe9dcc929be8a30053472a727f" name="afd8138fe9dcc929be8a30053472a727f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8138fe9dcc929be8a30053472a727f">&#9670;&#160;</a></span>QCBOR_TYPE_URI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_URI&#160;&#160;&#160;44</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A URI as defined in RFC 3986. Data is in <code>val.string</code>. </p>

</div>
</div>
<a id="a36b3f0da822b2367dd81554f57d6ba4e" name="a36b3f0da822b2367dd81554f57d6ba4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b3f0da822b2367dd81554f57d6ba4e">&#9670;&#160;</a></span>QCBOR_TYPE_UUID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QCBOR_TYPE_UUID&#160;&#160;&#160;49</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binary UUID per RFC 4122. Data is in <code>val.string</code>. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="adb1477d3286dd0b0f64e55886b5d2309" name="adb1477d3286dd0b0f64e55886b5d2309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1477d3286dd0b0f64e55886b5d2309">&#9670;&#160;</a></span>QCBORDecodeContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _QCBORDecodeContext <a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QCBORDecodeContext holds the context for decoding CBOR. It is about 300 bytes, so it can go on the stack. The contents are opaque, and the caller should not access any internal items. A context may be re-used serially as long as it is re initialized. </p>

</div>
</div>
<a id="af9cda6b7e1f5c811c87a80551f2f5647" name="af9cda6b7e1f5c811c87a80551f2f5647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cda6b7e1f5c811c87a80551f2f5647">&#9670;&#160;</a></span>QCBORItem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct___q_c_b_o_r_item.html">_QCBORItem</a> <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This holds a decoded data item. It is returned by the <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Preorder traversal like QCBORDecode_VGetNext() without use of internal error state.">QCBORDecode_GetNext()</a>, the principle decoding function. It holds the type, value, label, tags and other details of the decoded data item.</p>
<p>This is typically 56 bytes on 64-bit CPUs and 52 bytes on 32-bit CPUs (the CPU and the system's ABI determine this size). </p>

</div>
</div>
<a id="ad6bb723c2756e4d4ccb20531a68bd22e" name="ad6bb723c2756e4d4ccb20531a68bd22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bb723c2756e4d4ccb20531a68bd22e">&#9670;&#160;</a></span>QCBORStringAllocate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_useful_buf_8h.html#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a>(* QCBORStringAllocate) (void *pAllocateCxt, void *pOldMem, size_t uNewSize)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype for the implementation of a string allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pAllocateCxt</td><td>Pointer to context for the particular allocator implementation. Its contents depend on how a particular string allocator works. Typically, it will contain a pointer to the memory pool and some booking keeping data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pOldMem</td><td>Points to some memory previously allocated that is either to be freed or to be reallocated to be larger. It is <code>NULL</code> for new allocations and when called as the destructor.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uNewSize</td><td>Size of memory to be allocated or new size for a chunk being reallocated. Zero when called to free memory or when called as the destructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either the allocated buffer is returned, or <a class="el" href="_useful_buf_8h.html#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a>. <a class="el" href="_useful_buf_8h.html#aef281b38ce49e9413dad0893d225c70d">NULLUsefulBufC</a> is returned on a failed allocation and in the two cases where there is nothing to return.</dd></dl>
<p>This function must be implemented for a custom string allocator. See <a class="el" href="#aa27de6d54e1c52d4ccabb5304eac04e4" title="Sets up a custom string allocator for indefinite-length strings.">QCBORDecode_SetUpAllocator()</a>.</p>
<p>This is not needed if the built-in string allocator available through <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc" title="Set up the MemPool string allocator for indefinite-length strings.">QCBORDecode_SetMemPool()</a> is used.</p>
<p>After being set up by a call to <a class="el" href="#aa27de6d54e1c52d4ccabb5304eac04e4" title="Sets up a custom string allocator for indefinite-length strings.">QCBORDecode_SetUpAllocator()</a>, this is called back in four modes:</p>
<ul>
<li>allocate: <code>uNewSize</code> is the amount to allocate. <code>pOldMem</code> is <code>NULL</code>.</li>
<li>free: <code>uNewSize</code> is 0. <code>pOldMem</code> points to the memory to be freed. When the decoder calls this, it will always be for the most recent block that was either allocated or reallocated.</li>
<li>reallocate: <code>pOldMem</code> is the block to reallocate. <code>uNewSize</code> is its new size. When the decoder calls this, it will always be for the most recent block that was either allocated or reallocated.</li>
<li>destruct: <code>pOldMem</code> is <code>NULL</code> and <code>uNewSize</code> is 0. This is called when the decoding is complete by <a class="el" href="#a79109a9a307c93dddb8b582d4a3a9ceb" title="Check that a decode completed successfully.">QCBORDecode_Finish()</a>. Usually, the strings allocated by a string allocator are in use after the decoding is completed so this usually will not free those strings. Many string allocators will not need to do anything in this mode.</li>
</ul>
<p>The strings allocated by this will have <code>uDataAlloc</code> set to true in the <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> when they are returned. The user of the strings will have to free them. How they free them, depends on the design of the string allocator. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afb1592b19f254b747e6ad788189e8c58" name="afb1592b19f254b747e6ad788189e8c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1592b19f254b747e6ad788189e8c58">&#9670;&#160;</a></span>QCBORDecodeMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#afb1592b19f254b747e6ad788189e8c58">QCBORDecodeMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are the decode configuration flags that can be or'd together and passed to <a class="el" href="#afd546a1e4c3c30b2bf286495e9f963f4">QCBORDecode_Init()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58a25dbb7ce42d1c8113a26c9d14a417ccf" name="afb1592b19f254b747e6ad788189e8c58a25dbb7ce42d1c8113a26c9d14a417ccf"></a>QCBOR_DECODE_MODE_NORMAL&#160;</td><td class="fielddoc"><p>Normal decoding with no flags set. </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58a4116f650e4fa0e0279371dff415152c7" name="afb1592b19f254b747e6ad788189e8c58a4116f650e4fa0e0279371dff415152c7"></a>QCBOR_DECODE_MODE_MAP_STRINGS_ONLY&#160;</td><td class="fielddoc"><p>Required map labels to be strings. If not <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a72071afbe1fe98d8b5b8e798e2b50878">QCBOR_ERR_MAP_LABEL_TYPE</a> occurs. </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58aff9fda08b08890a0d6fb6fa362d0c4e5" name="afb1592b19f254b747e6ad788189e8c58aff9fda08b08890a0d6fb6fa362d0c4e5"></a>QCBOR_DECODE_MODE_MAP_AS_ARRAY&#160;</td><td class="fielddoc"><p>Causes maps to be treated as special arrays so all types of map labels can be decoded.. They will be returned with special <code>uDataType</code> <a class="el" href="#ad02b6f79a71304eda226a7ac33305479">QCBOR_TYPE_MAP_AS_ARRAY</a> and <code>uCount</code>, the number of items, will be double what it would be for a normal map because the labels are also counted. This mode is useful for decoding CBOR that has labels that are not integers or strings. Each map entry is decoded with two Get() calls, one for the label and one for the value. <a class="el" href="struct___q_c_b_o_r_item.html#a17d59c04615760797e068f11a2d81195">QCBORItem.label</a> is never filled in. </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58a18cb30849d11cd00a802da8abfc0538e" name="afb1592b19f254b747e6ad788189e8c58a18cb30849d11cd00a802da8abfc0538e"></a>QCBOR_DECODE_ALLOW_UNPROCESSED_TAG_NUMBERS&#160;</td><td class="fielddoc"><p>Makes QCBOR v2 tag decoding compatible with QCBOR v1. The error <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a625788c9f11659d2a479f1adcd3def9e">QCBOR_ERR_UNPROCESSED_TAG_NUMBER</a> is not returned. See <a class="el" href="#v2-Tag-Decoding">v2-Tag-Decoding</a> and <a class="el" href="#afc65a0f8f3aed0e4d193e68753e1c9e2" title="[Deprecated] Configure CBOR decoder context for QCBOR v1 compatibility.">QCBORDecode_CompatibilityV1()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58a0b86744331dc75040225acb376c7d8b0" name="afb1592b19f254b747e6ad788189e8c58a0b86744331dc75040225acb376c7d8b0"></a>QCBOR_DECODE_NO_INDEF_LENGTH&#160;</td><td class="fielddoc"><p>Error out on indefinite length strings, arrays and maps. </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58a8acf951606a01693e680ce2476e7773e" name="afb1592b19f254b747e6ad788189e8c58a8acf951606a01693e680ce2476e7773e"></a>QCBOR_DECODE_ONLY_PREFERRED_NUMBERS&#160;</td><td class="fielddoc"><p>Error out if integers or floats are encoded as non-preferred. </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58a46015d00c10d92a1cdba0f7ccf1a25ac" name="afb1592b19f254b747e6ad788189e8c58a46015d00c10d92a1cdba0f7ccf1a25ac"></a>QCBOR_DECODE_ONLY_PREFERRED_BIG_NUMBERS&#160;</td><td class="fielddoc"><p>If big numbers that will fit into normal integers are encountered error XXX will occur. This is to comply with big number preferred serialization. </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58a585e18a1a93a714801f096f832559e4b" name="afb1592b19f254b747e6ad788189e8c58a585e18a1a93a714801f096f832559e4b"></a>QCBOR_DECODE_ONLY_SORTED_MAPS&#160;</td><td class="fielddoc"><p>If maps are not sorted, error <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a088d4ac8fbc2c05de235bee2ed1753e0">QCBOR_ERR_UNSORTED</a> occurs. This is makes map decoding take more CPU time, but that is probably only of consequence with big maps on small CPUs. </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58ac2ab0da24b2225d3519a29a8302dc45a" name="afb1592b19f254b747e6ad788189e8c58ac2ab0da24b2225d3519a29a8302dc45a"></a>QCBOR_DECODE_ONLY_REDUCED_FLOATS&#160;</td><td class="fielddoc"><p>If whole number floats are present (they are not encoded as integers), error <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a13c0579cc9cf767ac0088c475d9d983d">QCBOR_ERR_DCBOR_CONFORMANCE</a> occurs. This is as required for dCBOR. </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58aef84bb42f39db401df3816b1205628e2" name="afb1592b19f254b747e6ad788189e8c58aef84bb42f39db401df3816b1205628e2"></a>QCBOR_DECODE_DISALLOW_DCBOR_SIMPLES&#160;</td><td class="fielddoc"><p>dCBOR allows only the simple types true, false and NULL This enforces that. </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58a78e3849a505bc197fffb601711d1c4cc" name="afb1592b19f254b747e6ad788189e8c58a78e3849a505bc197fffb601711d1c4cc"></a>QCBOR_DECODE_MODE_PREFERRED&#160;</td><td class="fielddoc"><p>This checks that the input is encoded with preferred serialization. The checking is performed as each item is decoded. If no QCBORDecode_GetXxx() is called for an item, there's no check on that item. Preferred serialization was first defined in section 4.1 of RFC 8949, but is more sharply in draft-ietf-cbor-cde. Summarizing, the requirements are: the use of definite-length encoding only, integers, including string lengths and tags, must be in shortest form, and floating-point numbers must be reduced to shortest form all the way to half-precision. </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58a98b83b788b6234b0b57575da5ffe4a49" name="afb1592b19f254b747e6ad788189e8c58a98b83b788b6234b0b57575da5ffe4a49"></a>QCBOR_DECODE_MODE_CDE&#160;</td><td class="fielddoc"><p>This checks that maps in the input are sorted by label as described in RFC 8949 section 4.2.1. This also performs duplicate label checking. This mode adds considerable CPU-time expense to decoding, though it is probably only of consequence for large inputs on slow CPUs.</p>
<p>This also performs all the checks that <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a78e3849a505bc197fffb601711d1c4cc">QCBOR_DECODE_MODE_PREFERRED</a> does. </p>
</td></tr>
<tr><td class="fieldname"><a id="afb1592b19f254b747e6ad788189e8c58a09c12d274f55f75a76b9ace46491ea75" name="afb1592b19f254b747e6ad788189e8c58a09c12d274f55f75a76b9ace46491ea75"></a>QCBOR_DECODE_MODE_DCBOR&#160;</td><td class="fielddoc"><p>This requires integer-float unification. It performs all the checks that <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a98b83b788b6234b0b57575da5ffe4a49">QCBOR_DECODE_MODE_CDE</a> does. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afc65a0f8f3aed0e4d193e68753e1c9e2" name="afc65a0f8f3aed0e4d193e68753e1c9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc65a0f8f3aed0e4d193e68753e1c9e2">&#9670;&#160;</a></span>QCBORDecode_CompatibilityV1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBORDecode_CompatibilityV1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[Deprecated] Configure CBOR decoder context for QCBOR v1 compatibility. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated</a></b></dt><dd>The v2 tag number behavior is more correct. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The context to configure.</td></tr>
  </table>
  </dd>
</dl>
<p>This performs two actions to make QCBOR v2 decoding compatible with v1.</p>
<p>First, it sets <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a18cb30849d11cd00a802da8abfc0538e">QCBOR_DECODE_ALLOW_UNPROCESSED_TAG_NUMBERS</a> which causes no error to be returned when un processed tag numbers are encountered.</p>
<p>Second, it installs all the same tag content handlers that were hardwired in v1. QCBORDecode_InstallTagDecoders(pMe, QCBORDecode_TagDecoderTablev1, NULL);</p>
<p>This is listed as deprecated even though it is new in QCBOR v2 because it recommended that v1 mode not be used because the tag number processing is too loose. See <a class="el" href="#v2-Tag-Decoding">v2-Tag-Decoding</a>.</p>
<p>This links in a fair bit of object code for all the tag content handlers that were always present in v1. To get the v1 tag number behavior without the object code for the tag content handlers, pass <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a18cb30849d11cd00a802da8abfc0538e">QCBOR_DECODE_ALLOW_UNPROCESSED_TAG_NUMBERS</a> to <a class="el" href="#afd546a1e4c3c30b2bf286495e9f963f4">QCBORDecode_Init()</a>. </p>

</div>
</div>
<a id="a56145f4f357e51e2e9f907cc40748186" name="a56145f4f357e51e2e9f907cc40748186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56145f4f357e51e2e9f907cc40748186">&#9670;&#160;</a></span>QCBORDecode_EndCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBORDecode_EndCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell whether cursor is at end of the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code possibly indicating end of input.</dd></dl>
<p>This returns the same as <a class="el" href="#aebef248b27efd73071bbdd345413504f" title="Get the decoding error.">QCBORDecode_GetError()</a> except that <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a67a3ab1048bd3970d380ca7e4ebf6582">QCBOR_ERR_NO_MORE_ITEMS</a> is returned if the travseral cursor is at the end of the CBOR input bytes (not the end of an entered array or map). </p>

</div>
</div>
<a id="a79109a9a307c93dddb8b582d4a3a9ceb" name="a79109a9a307c93dddb8b582d4a3a9ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79109a9a307c93dddb8b582d4a3a9ceb">&#9670;&#160;</a></span>QCBORDecode_Finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBORDecode_Finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that a decode completed successfully. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The context to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The internal tracked decode error or <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42af59ba798361a9a941d7312c6304a6fba">QCBOR_SUCCESS</a>.</dd></dl>
<p>Please see <a class="el" href="#Decode-Errors-Overview">Decode Errors Overview</a>.</p>
<p>This should always be called at the end of a decode to determine if it completed successfully. For some protocols, checking the return value here may be the only error check necessary.</p>
<p>This returns the internal tracked error if the decoder is in the error state, the same one returned by <a class="el" href="#aebef248b27efd73071bbdd345413504f" title="Get the decoding error.">QCBORDecode_GetError()</a>. This performs final checks at the end of the decode, and may also return <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a5880606db007bdf5dba9498ea877fd84">QCBOR_ERR_ARRAY_OR_MAP_STILL_OPEN</a> or <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a52c51d8c1ab843c1c1d550414ea378ad">QCBOR_ERR_EXTRA_BYTES</a>.</p>
<p>This calls the destructor for the string allocator, if one is in use. Because of this, It can't be called multiple times like <a class="el" href="#a0686470b7e1fe34f99ebd2b6b1728bfe" title="Return number of bytes consumed so far.">QCBORDecode_PartialFinish()</a>.</p>
<p>Some CBOR protocols use a CBOR sequence defined in <a href="https://tools.ietf.org/html/rfc8742">RFC 8742</a>. A CBOR sequence typically doesn't start out with a map or an array. The end of the CBOR is determined in some other way, perhaps by external framing, or by the occurrence of some particular CBOR data item or such. The buffer given to decode must start out with valid CBOR, but it can have extra bytes at the end that are not CBOR or CBOR that is to be ignored.</p>
<p><a class="el" href="#a79109a9a307c93dddb8b582d4a3a9ceb" title="Check that a decode completed successfully.">QCBORDecode_Finish()</a> should still be called when decoding CBOR sequences to check that the input decoded was well-formed. If the input was well-formed and there are extra bytes at the end <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a52c51d8c1ab843c1c1d550414ea378ad">QCBOR_ERR_EXTRA_BYTES</a> will be returned. This can be considered a successful decode. See also <a class="el" href="#a0686470b7e1fe34f99ebd2b6b1728bfe" title="Return number of bytes consumed so far.">QCBORDecode_PartialFinish()</a>. </p>

</div>
</div>
<a id="a62f099cf6959d73abf68e4b9cd09018d" name="a62f099cf6959d73abf68e4b9cd09018d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f099cf6959d73abf68e4b9cd09018d">&#9670;&#160;</a></span>QCBORDecode_GetAndResetError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBORDecode_GetAndResetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get and reset the decoding error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decoding error.</dd></dl>
<p>This returns the same as <a class="el" href="#aebef248b27efd73071bbdd345413504f" title="Get the decoding error.">QCBORDecode_GetError()</a> and also resets the error state to <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42af59ba798361a9a941d7312c6304a6fba">QCBOR_SUCCESS</a>. </p>

</div>
</div>
<a id="aebef248b27efd73071bbdd345413504f" name="aebef248b27efd73071bbdd345413504f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebef248b27efd73071bbdd345413504f">&#9670;&#160;</a></span>QCBORDecode_GetError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBORDecode_GetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the decoding error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decoding error.</dd></dl>
<p>Please see <a class="el" href="#Decode-Errors-Overview">Decode Errors Overview</a>.</p>
<p>The returns the tracked internal error code. All decoding functions set the internal error except <a class="el" href="#a5822b9efabd2a4bb1ce13390bf378b61" title="Preorder traversal like QCBORDecode_VGetNext() without use of internal error state.">QCBORDecode_GetNext()</a> and <a class="el" href="#ae831dd403624d9f5d57016d3ac8004e0" title="Get the next data item without consuming it without use of internal error state.">QCBORDecode_PeekNext()</a>.</p>
<p>For many protocols it is only necessary to check the return code from <a class="el" href="#a79109a9a307c93dddb8b582d4a3a9ceb" title="Check that a decode completed successfully.">QCBORDecode_Finish()</a> at the end of all the decoding. It is unnecessary to call this.</p>
<p>For some protocols, the decoding sequence depends on the types, values or labels of data items. If so, this must be called before using decoded values to know the decode was a success and the type, value and label is valid.</p>
<p>Some errors, like integer conversion overflow, date string format may not affect the flow of a protocol. The protocol decoder may wish to proceed even if they occur. In that case <a class="el" href="#a62f099cf6959d73abf68e4b9cd09018d" title="Get and reset the decoding error.">QCBORDecode_GetAndResetError()</a> may be called after these data items are fetched. </p>

</div>
</div>
<a id="a5822b9efabd2a4bb1ce13390bf378b61" name="a5822b9efabd2a4bb1ce13390bf378b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5822b9efabd2a4bb1ce13390bf378b61">&#9670;&#160;</a></span>QCBORDecode_GetNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBORDecode_GetNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *</td>          <td class="paramname"><span class="paramname"><em>pDecodedItem</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preorder traversal like <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a> without use of internal error state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDecodedItem</td><td>The decoded CBOR item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See error table of decoding errors set by <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a>.</dd></dl>
<p>This is the same as <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a> except it doesn't set the internal decoding error and will attempt to decode even if the decoder is in the error state. </p>

</div>
</div>
<a id="afd546a1e4c3c30b2bf286495e9f963f4" name="afd546a1e4c3c30b2bf286495e9f963f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd546a1e4c3c30b2bf286495e9f963f4">&#9670;&#160;</a></span>QCBORDecode_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBORDecode_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_useful_buf_8h.html#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a></td>          <td class="paramname"><span class="paramname"><em>EncodedCBOR</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afb1592b19f254b747e6ad788189e8c58">QCBORDecodeMode</a></td>          <td class="paramname"><span class="paramname"><em>uConfigFlags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the CBOR decoder context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The context to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EncodedCBOR</td><td>The buffer with CBOR encoded bytes to be decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uConfigFlags</td><td>See <a class="el" href="#afb1592b19f254b747e6ad788189e8c58">QCBORDecodeMode</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Initialize the decoder context with the encoded CBOR to be decoded.</p>
<p>For typical use, <code>uConfigFlags</code> is zero (<a class="el" href="#afb1592b19f254b747e6ad788189e8c58a25dbb7ce42d1c8113a26c9d14a417ccf">QCBOR_DECODE_MODE_NORMAL</a>). See configuration flags that can be or'd defined in <a class="el" href="#afb1592b19f254b747e6ad788189e8c58">QCBORDecodeMode</a>.</p>
<p>If indefinite-length strings are to be decoded, then <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc" title="Set up the MemPool string allocator for indefinite-length strings.">QCBORDecode_SetMemPool()</a> or <a class="el" href="#aa27de6d54e1c52d4ccabb5304eac04e4" title="Sets up a custom string allocator for indefinite-length strings.">QCBORDecode_SetUpAllocator()</a> must be additionally called to set up a string allocator. </p>

</div>
</div>
<a id="adb33f2631b4f610562a06ffe189aec58" name="adb33f2631b4f610562a06ffe189aec58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb33f2631b4f610562a06ffe189aec58">&#9670;&#160;</a></span>QCBORDecode_IsNotWellFormedError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool QCBORDecode_IsNotWellFormedError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a></td>          <td class="paramname"><span class="paramname"><em>uErr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether an error indicates non-well-formed CBOR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uErr</td><td>The QCBOR error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the error code indicates non-well-formed CBOR. </dd></dl>

</div>
</div>
<a id="a660c86af310f033cf3d4a264354616f9" name="a660c86af310f033cf3d4a264354616f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660c86af310f033cf3d4a264354616f9">&#9670;&#160;</a></span>QCBORDecode_IsUnrecoverableError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool QCBORDecode_IsUnrecoverableError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a></td>          <td class="paramname"><span class="paramname"><em>uErr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether a decoding error is recoverable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uErr</td><td>The QCBOR error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the error code indicates and uncrecoverable error.</dd></dl>
<p>When an error is unrecoverable, no further decoding of the input is possible. CBOR is a compact format with almost no redundancy so errors like incorrect lengths or array counts are unrecoverable. Unrecoverable errors also occur when implementation limits such as the limit on array and map nesting are encountered. When the built-in decoding of a tag like an epoch date encounters an error such as a data item of an unexpected type, this is also an unrecoverable error because the internal decoding doesn't try to decode everything in the tag.</p>
<p>The unrecoverable errors are a range of the errors in <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a>. </p>

</div>
</div>
<a id="a0686470b7e1fe34f99ebd2b6b1728bfe" name="a0686470b7e1fe34f99ebd2b6b1728bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0686470b7e1fe34f99ebd2b6b1728bfe">&#9670;&#160;</a></span>QCBORDecode_PartialFinish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBORDecode_PartialFinish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>puConsumed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of bytes consumed so far. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The context to check. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">puConsumed</td><td>The number of bytes consumed so far. May be <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same as <a class="el" href="#a79109a9a307c93dddb8b582d4a3a9ceb" title="Check that a decode completed successfully.">QCBORDecode_Finish()</a>;</dd></dl>
<p>This is primarily for partially decoding CBOR sequences. It is the same as <a class="el" href="#a79109a9a307c93dddb8b582d4a3a9ceb" title="Check that a decode completed successfully.">QCBORDecode_Finish()</a> except it returns the number of bytes consumed and doesn't call the destructor for the string allocator (See <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc">QCBORDecode_SetMemPool()</a>).</p>
<p>When this is called before all input bytes are consumed, <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a52c51d8c1ab843c1c1d550414ea378ad">QCBOR_ERR_EXTRA_BYTES</a> will be returned as <a class="el" href="#a79109a9a307c93dddb8b582d4a3a9ceb" title="Check that a decode completed successfully.">QCBORDecode_Finish()</a> does. For typical use of this, that particular error is disregarded.</p>
<p>Decoding with the same <a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> can continue after calling this and this may be called many times.</p>
<p>Another way to resume decoding is to call <a class="el" href="#afd546a1e4c3c30b2bf286495e9f963f4">QCBORDecode_Init()</a> with the bytes not decoded, but this only works on CBOR sequences when the decoding stopped with no open arrays, maps or byte strings. </p>

</div>
</div>
<a id="ae831dd403624d9f5d57016d3ac8004e0" name="ae831dd403624d9f5d57016d3ac8004e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae831dd403624d9f5d57016d3ac8004e0">&#9670;&#160;</a></span>QCBORDecode_PeekNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBORDecode_PeekNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *</td>          <td class="paramname"><span class="paramname"><em>pDecodedItem</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next data item without consuming it without use of internal error state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDecodedItem</td><td>The decoded CBOR item.</td></tr>
  </table>
  </dd>
</dl>
<p>This is the same as <a class="el" href="#a72885c0d5577b9ebb389e3f12269de80" title="Get the next data item without consuming it.">QCBORDecode_VPeekNext()</a> except it doesn't set the internal decoding error and will attempt to decode even if the decoder is in the error state. </p>

</div>
</div>
<a id="a7c990fd11f2cf6791674633efce94bc7" name="a7c990fd11f2cf6791674633efce94bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c990fd11f2cf6791674633efce94bc7">&#9670;&#160;</a></span>QCBORDecode_RetrieveUndecodedInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_useful_buf_8h.html#ad5ebb3732bd85ff732cc817fc280cc64">UsefulBufC</a> QCBORDecode_RetrieveUndecodedInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the undecoded input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decode context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input that was given to <a class="el" href="#afd546a1e4c3c30b2bf286495e9f963f4">QCBORDecode_Init()</a>.</dd></dl>
<p>A simple convenience method, should it be useful to get the original input back. </p>

</div>
</div>
<a id="a41b5979a9adfbc386fd7fc3081c8c880" name="a41b5979a9adfbc386fd7fc3081c8c880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b5979a9adfbc386fd7fc3081c8c880">&#9670;&#160;</a></span>QCBORDecode_SetError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void QCBORDecode_SetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a></td>          <td class="paramname"><span class="paramname"><em>uError</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually set error condition, or set user-defined error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uError</td><td>The error code to set.</td></tr>
  </table>
  </dd>
</dl>
<p>Once set, none of the QCBORDecode methods will do anything and the error code set will stay until cleared with <a class="el" href="#a62f099cf6959d73abf68e4b9cd09018d" title="Get and reset the decoding error.">QCBORDecode_GetAndResetError()</a>. A user-defined error can be set deep in some decoding layers to short-circuit further decoding and propagate up.</p>
<p>When the error condition is set, <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a> will always return an item with data and label type as <a class="el" href="#a5917b8146669036e62a49a54b5c4c601">QCBOR_TYPE_NONE</a>.</p>
<p>The main intent of this is to set a user-defined error code in the range of <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42af3d488cad4be2f0ce3f763bbc2958d17">QCBOR_ERR_FIRST_USER_DEFINED</a> to <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a653910f76d069d1858c9ad599d4a901d">QCBOR_ERR_LAST_USER_DEFINED</a>, but it is OK to set QCBOR-defined error codes too. </p>

</div>
</div>
<a id="aee2d572e423cfed0a2c774b2999c53dc" name="aee2d572e423cfed0a2c774b2999c53dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2d572e423cfed0a2c774b2999c53dc">&#9670;&#160;</a></span>QCBORDecode_SetMemPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42">QCBORError</a> QCBORDecode_SetMemPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_useful_buf_8h.html#a28f72e9ae0a9419e46735e16f8c2f449">UsefulBuf</a></td>          <td class="paramname"><span class="paramname"><em>MemPool</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bAllStrings</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up the MemPool string allocator for indefinite-length strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decode context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MemPool</td><td>The pointer and length of the memory pool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bAllStrings</td><td>If true, all strings, even of definite length, will be allocated with the string allocator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error if the MemPool was greater than <code>UINT32_MAX</code> or less than <a class="el" href="#ab4377ad62925e5d38c948b6a00ac52a0">QCBOR_DECODE_MIN_MEM_POOL_SIZE</a>.</dd></dl>
<p>Indefinite-length strings (text and byte) cannot be decoded unless there is a string allocator configured. MemPool is a simple built-in string allocator that allocates bytes from a memory pool handed to it by calling this function. The memory pool is just a pointer and length for some block of memory that is to be used for string allocation. It can come from the stack, heap or other.</p>
<p>The memory pool must be <a class="el" href="#ab4377ad62925e5d38c948b6a00ac52a0">QCBOR_DECODE_MIN_MEM_POOL_SIZE</a> plus space for all the strings allocated. There is no overhead per string allocated. A conservative way to size this buffer is to make it the same size as the CBOR being decoded plus <a class="el" href="#ab4377ad62925e5d38c948b6a00ac52a0">QCBOR_DECODE_MIN_MEM_POOL_SIZE</a>.</p>
<p>This memory pool is used for all indefinite-length strings that are text strings or byte strings, including strings used as labels.</p>
<p>The pointers to strings in <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> will point into the memory pool set here. They do not need to be individually freed. Just discard the buffer when they are no longer needed.</p>
<p>If <code>bAllStrings</code> is set, then the size will be the overhead plus the space to hold <b>all</b> strings, definite and indefinite-length, value or label. The advantage of this is that after the decode is complete, the original memory holding the encoded CBOR does not need to remain valid.</p>
<p>This simple allocator is not hard linked to the QCBOR decoder. Assuming dead-stripping of unused symbols is being performed, this simple allocator will not be linked in unless <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc" title="Set up the MemPool string allocator for indefinite-length strings.">QCBORDecode_SetMemPool()</a> is called.</p>
<p>See also <a class="el" href="#aa27de6d54e1c52d4ccabb5304eac04e4" title="Sets up a custom string allocator for indefinite-length strings.">QCBORDecode_SetUpAllocator()</a> to set up a custom allocator if this one isn't sufficient. </p>

</div>
</div>
<a id="aa27de6d54e1c52d4ccabb5304eac04e4" name="aa27de6d54e1c52d4ccabb5304eac04e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27de6d54e1c52d4ccabb5304eac04e4">&#9670;&#160;</a></span>QCBORDecode_SetUpAllocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void QCBORDecode_SetUpAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad6bb723c2756e4d4ccb20531a68bd22e">QCBORStringAllocate</a></td>          <td class="paramname"><span class="paramname"><em>pfAllocateFunction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>pAllocateContext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bAllStrings</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up a custom string allocator for indefinite-length strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context to set up an allocator for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfAllocateFunction</td><td>Pointer to function that will be called by QCBOR for allocations and frees. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pAllocateContext</td><td>Context passed to <code>pfAllocateFunction</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bAllStrings</td><td>If true, all strings, even of definite length, will be allocated with the string allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>Indefinite-length strings (text and byte) cannot be decoded unless a string allocator is configured. <a class="el" href="#aa27de6d54e1c52d4ccabb5304eac04e4" title="Sets up a custom string allocator for indefinite-length strings.">QCBORDecode_SetUpAllocator()</a> allows the caller to configure an external string allocator implementation if the internal string allocator is unsuitable. See <a class="el" href="#aee2d572e423cfed0a2c774b2999c53dc" title="Set up the MemPool string allocator for indefinite-length strings.">QCBORDecode_SetMemPool()</a> to configure the internal allocator.</p>
<p>The string allocator configured here is a custom one designed and implemented by the caller. See <a class="el" href="#ad6bb723c2756e4d4ccb20531a68bd22e">QCBORStringAllocate</a> for the requirements for a string allocator implementation.</p>
<p>A malloc-based string external allocator can be obtained by calling <code>QCBORDecode_MakeMallocStringAllocator()</code>. It will return a function and pointer that can be given here as <code>pAllocatorFunction</code> and <code>pAllocatorContext</code>. It uses standard <code>malloc()</code> so <code>free()</code> must be called on all strings marked by <code>uDataAlloc</code> <code>==</code> <code>1</code> or <code>uLabelAlloc</code> <code>==</code> <code>1</code> in <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a>. Note this is in a separate GitHub repository. </p>

</div>
</div>
<a id="aef77ea67ae26675fda35b91d1dcc5cc6" name="aef77ea67ae26675fda35b91d1dcc5cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef77ea67ae26675fda35b91d1dcc5cc6">&#9670;&#160;</a></span>QCBORDecode_Tell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t QCBORDecode_Tell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current traversal cursort offset in the input CBOR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The traversal cursor offset or <code>UINT32_MAX</code>.</dd></dl>
<p>The position returned is always the start of the next item that would be next decoded with <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a>. The cursor returned may be at the end of the input in which case the next call to <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a> will result in the <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a67a3ab1048bd3970d380ca7e4ebf6582">QCBOR_ERR_NO_MORE_ITEMS</a>. See also QCBORDecode_AtEnd().</p>
<p>If the decoder is in error state from previous decoding, <code>UINT32_MAX</code> is returned.</p>
<p>When decoding map items, the position returned is always of the label, never the value.</p>
<p>For indefinite-length arrays and maps, the break byte is consumed when the last item in the array or map is consumed so the cursor is at the next item to be decoded as expected.</p>
<p>There are some special rules for the traversal cursor when fetching map items by label. See the description of <a class="el" href="qcbor__spiffy__decode_8h.html#SpiffyDecode">SpiffyDecode</a>.</p>
<p>When traversal is bounded because an array or map has been entered (e.g., <a class="el" href="qcbor__spiffy__decode_8h.html#abf081de36c124715acbb32d6fdd4f0a8" title="Enter a map for decoding and searching.">QCBORDecode_EnterMap()</a>) and all items in the array or map have been consumed, the position returned will be of the item outside of the array or map. The array or map must be exited before <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a> will decode it.</p>
<p>In many cases the position returned will be in the middle of an array or map. It will not be possible to start decoding at that location with another instance of the decoder and go to the end. It is not valid CBOR. If the input is a CBOR sequence and the position is not in the moddle of an array or map then it is possible to decode to the end.</p>
<p>There is no corresponding seek method because it is too complicated to restore the internal decoder state that tracks nesting. </p>

</div>
</div>
<a id="a247d735e59b26e9dfab807b045d1b01b" name="a247d735e59b26e9dfab807b045d1b01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247d735e59b26e9dfab807b045d1b01b">&#9670;&#160;</a></span>QCBORDecode_VGetNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBORDecode_VGetNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *</td>          <td class="paramname"><span class="paramname"><em>pDecodedItem</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDecodedItem</td><td>The decoded CBOR item.</td></tr>
  </table>
  </dd>
</dl>
<p><code>pDecodedItem</code> is filled from the decoded item. Generally, the following data is returned in the structure:</p>
<ul>
<li><code>uDataType</code> which indicates which member of the <code>val</code> union the data is in. This decoder figures out the type based on the CBOR major type, the CBOR "additionalInfo", and sometimes by preceding tag numbers.</li>
<li>The value of the item, which might be an integer, a pointer and a length, the count of items in an array, a floating-point number or other.</li>
<li>The nesting level for maps and arrays.</li>
<li>The label for an item in a map, which may be a text or byte string or an integer.</li>
<li>When <a class="el" href="#afb1592b19f254b747e6ad788189e8c58a18cb30849d11cd00a802da8abfc0538e">QCBOR_DECODE_ALLOW_UNPROCESSED_TAG_NUMBERS</a> is set, unprocessed tag numbers.</li>
</ul>
<p>See <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> for all the details about what is returned.</p>
<p>This function handles arrays and maps. When an array or map is first encountered a <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> will be returned with major type <a class="el" href="#aa4d5e4cd1373d0da4e537be46fb6960f">QCBOR_TYPE_ARRAY</a> or <a class="el" href="#ac2d68008ebd9bf49e4417a21be81e429">QCBOR_TYPE_MAP</a>. <code>QCBORItem.val.uNestLevel</code> gives the nesting level of the opening of the array or map. When the next item is fetched, it will be the first one in the array or map and its <code>QCBORItem.val.uNestLevel</code> will be one more than that of the opening of the array or map.</p>
<p>Nesting level 0 is the top-most nesting level. The first item decoded always has nesting level 0. A map or array at the top level has nesting level 0 and the members of the array or map have nesting level 1.</p>
<p>Here is an example of how the nesting level is reported for a CBOR sequence with no arrays or maps at all.</p>
<div class="fragment"><div class="line">Data Item           Nesting Level</div>
<div class="line">integer                     0</div>
<div class="line"><span class="keywordtype">byte</span> <span class="keywordtype">string</span>                 0</div>
</div><!-- fragment --><p>Here is an example of how the nesting level is reported for a CBOR sequence with a simple array and some top-level items.</p>
<div class="fragment"><div class="line">Data Item           Nesting Level</div>
<div class="line">integer                     0</div>
<div class="line">array with 2 items          0</div>
<div class="line">   <span class="keywordtype">byte</span> <span class="keywordtype">string</span>              1</div>
<div class="line">   <span class="keywordtype">byte</span> <span class="keywordtype">string</span>              1</div>
<div class="line">integer                     0</div>
</div><!-- fragment --><p>Here's a more complex example that is not a CBOR sequence</p>
<div class="fragment"><div class="line">Data Item           Nesting Level</div>
<div class="line">map with 4 items            0</div>
<div class="line">   text <span class="keywordtype">string</span>              1</div>
<div class="line">   array with 3 integers    1</div>
<div class="line">      integer               2</div>
<div class="line">      integer               2</div>
<div class="line">      integer               2</div>
<div class="line">   text <span class="keywordtype">string</span>              1</div>
<div class="line">   <span class="keywordtype">byte</span> <span class="keywordtype">string</span>              1</div>
</div><!-- fragment --><p>In <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a>, <code>uNextNestLevel</code> is the nesting level for the next call to <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a>. It indicates if any maps or arrays were closed out during the processing of the just-fetched <a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a>. This processing includes a look-ahead for any breaks that close out indefinite-length arrays or maps. This value is needed to be able to understand the hierarchical structure. If <code>uNextNestLevel</code> is not equal to <code>uNestLevel</code> the end of the current map or array has been encountered. This works for both definite and indefinite-length arrays so it is the best way to find the end of a map or array. Alternatively, for definite-length arrays, <code><a class="el" href="struct___q_c_b_o_r_item.html#ada1db914c30f5d52f4df8f51f17fed9b">QCBORItem.val.uCount</a></code> contains the number of items in the array. For indefinite-length arrays, <code><a class="el" href="struct___q_c_b_o_r_item.html#ada1db914c30f5d52f4df8f51f17fed9b">QCBORItem.val.uCount</a></code> is <code>UINT16_MAX</code>.</p>
<p>See <a class="el" href="#Decode-Errors-Overview">Decode Error Overview</a>.</p>
<p>If a decoding error occurs or previously occured, <code>uDataType</code> and <code>uLabelType</code> will be set to <a class="el" href="#a5917b8146669036e62a49a54b5c4c601">QCBOR_TYPE_NONE</a>. If there is no need to know the specific error, it is sufficient to check for <a class="el" href="#a5917b8146669036e62a49a54b5c4c601">QCBOR_TYPE_NONE</a>.</p>
<p>Errors fall in several categories:</p>
<ul>
<li>Not well-formed errors are those where there is something syntactically and fundamentally wrong with the CBOR being decoded. Decoding should stop completely.</li>
<li>Invalid CBOR is well-formed, but still not correct. It is probably best to stop decoding, but not necessary.</li>
<li>This implementation has some size limits. They should rarely be encountered. If they are it may because something is wrong with the CBOR, for example an array size is incorrect.</li>
<li>There are a few CBOR constructs that are not handled without some extra configuration. These are indefinite length strings and maps with labels that are not strings or integers. See <a class="el" href="#afd546a1e4c3c30b2bf286495e9f963f4">QCBORDecode_Init()</a>. Also, the QCBOR library may have been compiled with some features disabled to reduce code size and this can result in some errors.</li>
<li>Resource exhaustion. This only occurs when a string allocator is configured to handle indefinite-length strings as other than that, this implementation does no dynamic memory allocation.</li>
</ul>
<p>x | <b>Not well-formed errors</b> || | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42af851c38293b14b0335c65b02140e8a3d">QCBOR_ERR_HIT_END</a> | Partial data item; need more input bytes to complete decoding | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a7976ba2a67d65d4b0048fcafbf183655">QCBOR_ERR_UNSUPPORTED</a> | Input contains CBOR with reserved additional info values | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a0852c482624679ad92815ff5f5c07657">QCBOR_ERR_BAD_TYPE_7</a> | Simple value encoded as two-byte integer rather than one | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a30db911b5d817e7a56499f50a3b59dfa">QCBOR_ERR_BAD_BREAK</a> | Break occured outside an indefinite-length map or such | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a2a5d4809171907c205e23e23c97a1a14">QCBOR_ERR_BAD_INT</a> | Length of integer is bad | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a90bbf40200a6be9f7838db9557eff274">QCBOR_ERR_INDEFINITE_STRING_CHUNK</a> | One of the chunks in indefinite-length string is the wrong type | | <b>Invalid CBOR</b> || | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a67a3ab1048bd3970d380ca7e4ebf6582">QCBOR_ERR_NO_MORE_ITEMS</a> | Need more input data items to decode | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42ad115ac19ae04157501c3faf68477cad2">QCBOR_ERR_BAD_EXP_AND_MANTISSA</a> | The structure of a big float or big number is invalid | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a638076c60c559bb6bfd3f0f85f7f8727">QCBOR_ERR_UNRECOVERABLE_TAG_CONTENT</a> | The content of a tag is of the wrong type | | <b>Implementation Limits</b> || | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42ab4148715700ffcc769193f2c47bec7ec">QCBOR_ERR_INT_OVERFLOW</a> | Input integer smaller than INT64_MIN | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a1044faf8d1fa413e2d036891e6d9b8f1">QCBOR_ERR_ARRAY_DECODE_TOO_LONG</a> | Array or map has more elements than can be handled | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a042e4c7585f18aed1883721ad0cde1fe">QCBOR_ERR_DATE_OVERFLOW</a> | Date larger than can be handled | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42aecb4afa00ddf2e2919bc1d1d28cc66b1">QCBOR_ERR_ARRAY_DECODE_NESTING_TOO_DEEP</a> | Nesting deeper than can be handled | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a2478870a204a67084fd898d02d6c49f3">QCBOR_ERR_STRING_TOO_LONG</a> | Encountered a string longer than size_t can hold less 4 bytes | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42ad1256c54a3aabfc05e434272d510d222">QCBOR_ERR_TOO_MANY_TAGS</a> | Tag nesting deeper than limit, typically 4 | | <b>Configuration errors</b> || | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a64e0fa8767c2d022ecd7885ab2653664">QCBOR_ERR_NO_STRING_ALLOCATOR</a> | Encountered indefinite-length string with no allocator configured | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a72071afbe1fe98d8b5b8e798e2b50878">QCBOR_ERR_MAP_LABEL_TYPE</a> | A map label that is not a string on an integer | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a19200505d3bbed61a9403640e73b6531">QCBOR_ERR_HALF_PRECISION_DISABLED</a> | Half-precision input, but disabled in QCBOR library | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a6a77dfb3e29b9c5af287a259469710a5">QCBOR_ERR_INDEF_LEN_ARRAYS_DISABLED</a> | Indefinite-length input, but disabled in QCBOR library | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a3c666e83932bb963e8191cd71edb6c88">QCBOR_ERR_INDEF_LEN_STRINGS_DISABLED</a> | Indefinite-length input, but disabled in QCBOR library | | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42a6bfbf967036351e9e1f57ac099c43add">QCBOR_ERR_ALL_FLOAT_DISABLED</a> | Library compiled with floating-point support turned off. | | <b>Resource exhaustion errors</b> || | <a class="el" href="qcbor__common_8h.html#a917c840b71af72c2cdd4b31bb2a4fb42ac137e2e0f81190b6cbb0dbd8837f16e8">QCBOR_ERR_STRING_ALLOCATE</a> | The string allocator is unable to allocate more memory | </p>

</div>
</div>
<a id="a98fbaea20b6c61e0bf56ac26ebce6139" name="a98fbaea20b6c61e0bf56ac26ebce6139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98fbaea20b6c61e0bf56ac26ebce6139">&#9670;&#160;</a></span>QCBORDecode_VGetNextConsume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBORDecode_VGetNextConsume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *</td>          <td class="paramname"><span class="paramname"><em>pDecodedItem</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next item, fully consuming it if it is a map or array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDecodedItem</td><td>The decoded CBOR item.</td></tr>
  </table>
  </dd>
</dl>
<p><code>pItem</code> returned is the same as <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a>. If the item is an array or map, the entire contents of the array or map will be consumed leaving the cursor after the array or map.</p>
<p>If an array or map is being consumed by this, an error will occur if any of the items in the array or map are in error.</p>
<p>If the item is a tag the contents of which is an array or map, like a big float, <code>pItem</code> will identify it as such and the contents will be consumed, but the validity of the tag won't be checked other than for being well-formed.</p>
<p>In order to go back to decode the contents of an array or map consumed by this, the decoder must be rewound using <a class="el" href="qcbor__spiffy__decode_8h.html#a6d89d5fa2aa5db9aba2f53a64257f998" title="Reset traversal cursor to start of map, array, byte-string wrapped CBOR or start of input.">QCBORDecode_Rewind()</a>. </p>

</div>
</div>
<a id="a72885c0d5577b9ebb389e3f12269de80" name="a72885c0d5577b9ebb389e3f12269de80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72885c0d5577b9ebb389e3f12269de80">&#9670;&#160;</a></span>QCBORDecode_VPeekNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCBORDecode_VPeekNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#adb1477d3286dd0b0f64e55886b5d2309">QCBORDecodeContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9cda6b7e1f5c811c87a80551f2f5647">QCBORItem</a> *</td>          <td class="paramname"><span class="paramname"><em>pDecodedItem</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next data item without consuming it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCtx</td><td>The decoder context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pDecodedItem</td><td>The decoded CBOR item.</td></tr>
  </table>
  </dd>
</dl>
<p>This is the same as <a class="el" href="#a247d735e59b26e9dfab807b045d1b01b" title="Get the next item (integer, byte string, array...) in the preorder traversal of the CBOR tree.">QCBORDecode_VGetNext()</a> but does not consume the data item. This only looks ahead one item. Calling it repeatedly will just return the same item over and over.</p>
<p>This uses about 200 bytes of stack, far more than anything else here in <a class="el" href="qcbor__main__decode_8h.html">qcbor_main_decode.h</a> because it saves a copy of most of the decode context temporarily.</p>
<p>This is useful for looking ahead to determine the type of a data item to know which type-specific spiffy decode function to call or decoding protocols where the types of later data items depending on type of earlier ones.</p>
<p>The error must be retrieved with <a class="el" href="#aebef248b27efd73071bbdd345413504f" title="Get the decoding error.">QCBORDecode_GetError()</a> and checked to know the peek was successful before referencing the contents of <code>pDecodedItem</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
